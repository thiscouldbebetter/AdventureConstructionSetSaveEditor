<html>
<body>

<div id="divUi">

	<h3>_Adventure Construction Set_ Save Editor</h3>

	<p>
		Upload an ADVEN.HRD file from the classic DOS-era game
		_Adventure Construction Set_ to see a text representation
		of its contents.  Some samples are provided
		<a href="../Demo/index.html">here</a>.
	</p>

	<div>
		<label>Adventure as JSON:</label>
		<input
			id="inputFile"
			type="file"
			onchange="UiEventHandler.inputFile_Changed(this)"
		></input>
		<br />
		<textarea
			id="textareaJson"
			cols="80" rows="25"
			spellcheck="false"
		></textarea>
	</div>
	<div>
		<button onclick="UiEventHandler.buttonSave_Clicked()">
			Save to File
		</button>
	</div>
</div>

<script type="text/javascript" src="BitHandling/Source/BitStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteConverter.js"></script>

<script type="text/javascript" src="BitHandling/Source/_Imports.js"></script>

<script type="text/javascript" src="TextDecoder.js"></script>

<script type="text/javascript">

class UiEventHandler
{
	static buttonSave_Clicked()
	{
		alert("Not yet implemented!");
	}

	static inputFile_Changed(inputFile)
	{
		var file = inputFile.files[0];
		if (file != null)
		{
			var fileReader = new FileReader();
			fileReader.onload = (event) =>
			{
				var adventureAsBinaryString =
					event.target.result;
				var adventureAsBytes =
					adventureAsBinaryString.split("").map(x => x.charCodeAt(0) );
				var adventure =
					Adventure.fromBytes(adventureAsBytes);
				var adventureAsJson = adventure.toJson();
				var d = document;
				var textareaJson =
					d.getElementById("textareaJson");
				textareaJson.value = adventureAsJson;
			};
			fileReader.readAsBinaryString(file);
		}
	}
}

// Classes.

class Adventure
{
	constructor
	(
		name,
		authorName,
		musicalThemeId,
		pictures,
		worldMap,
		regions,
		things,
		creatures,
		messages
	)
	{
		this.name = name;
		this.authorName = authorName;
		this.musicalThemeId = musicalThemeId;
		this.pictures = pictures;
		this.worldMap = worldMap;
		this.regions = regions;
		this.things = things;
		this.creatures = creatures;
		this.messages = messages;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var reader = ByteStream.fromBytes(bytes);

		// test
		reader.byteIndexSet(0x1b80a);
		var thing1NameEncodedAsBytes = reader.readBytes(10);
		var textDecoder = TextDecoder.Instance();
		var thing2Name =
			textDecoder.bytesDecodeToString(thing1NameEncodedAsBytes);
		alert("thing2Name is " + thing2Name);

		var messagesOffsetInBytes = 0x16C00;
		var messageSizeInBytes = 0x100;
		var messagesSoFar = [];
		var messagesCount = 255; // todo
		reader.byteIndexSet(messagesOffsetInBytes);
		for (var m = 0; m < messagesCount; m++)
		{
			var message = reader.readString(messagesOffsetInBytes);
			messagesSoFar.push(message);
		}

		var thingsOffsetInBytes = 0x1B800;
		reader.byteIndexSet(thingsOffsetInBytes);
		var thingsSoFar = [];
		var thingsCount = 100; // ?
		var thingSizeInBytes = 0x100; // ?
		for (var t = 0; t < thingsCount; t++)
		{
			var thingAsBytes = reader.readBytes(thingSizeInBytes);
			var thing = Thing.fromBytes(thingAsBytes);
			thingsSoFar.push(things);
		}

		var adventureNameOffsetInBytes = 0x1C200;
		reader.byteIndexSet(adventureNameOffsetInBytes);
		var adventureName = reader.readString(14);
		var authorName = reader.readString(14);

		reader.byteIndexSet(0x1C229);
		var regionCount = reader.readByte();
		var regionsSoFar = [];
		var regionsOffsetInBytes = 0x1C441;
		var regionSizeInBytes = 0x200;
		reader.byteIndexSet(regionsOffsetInBytes);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var regionAsBytes = reader.readBytes(regionSizeInBytes);
			var region = Region.fromBytes(regionAsBytes);
			regionsSoFar.push(region);
		}

		var worldMapOffsetInBytes = 0x1C42C;
		reader.byteIndexSet(worldMapOffsetInBytes);
		var worldMapSizeInBytes = 1000; // todo
		var worldMapAsBytes = reader.readBytes(worldMapSizeInBytes);
		var worldMap = WorldMap.fromBytes(worldMapAsBytes);

		reader.byteIndexSet(0x1C56e);
		var musicalThemeId = reader.readByte();

		var creaturesOffsetInBytes = 0x1CB0A;
		var creatureSizeInBytes = 0x300; // todo
		var creaturesCount = 100; // todo
		var creaturesSoFar = [];
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureAsBytes = reader.readBytes(creatureSizeInBytes);
			var creature = Creature.fromBytes(creatureAsBytes);
			creaturesSoFar.push(creature);
		}

		var adventure = new Adventure
		(
			adventureName,
			authorName,
			musicalThemeId,
			null, // pictures
			worldMap,
			null, // regions
			things,
			creatures,
			messages
		);
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Json.

	fromJson()
	{
		throw new Error("todo");
	}

	toJson()
	{
		return JSON.stringify(this, null, 4);
	}
}

class Creature
{
	constructor(id, name, typeId, attributes, other)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.attributes = attributes;
		this.other = other;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);

		var id = -1; // todo
		var name = "todo";
		var typeId = -1; // todo
		var attributesAsBytes = reader.readBytes(10);
		var attributes = CreatureAttribues.fromBytes();
		var other = reader.readBytes(0); // todo

		var creature = new Creature
		(
			id,
			name,
			typeId,
			attributes,
			other
		);

		return creature;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class CreatureAttributes
{
	constructor(constitution, unknown, wisdom)
	{
		this.constitution = constitution;
		this.unknown = unknown;
		this.wisdom = wisdom;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var bitStream = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var constitution = converter.bitsToInteger(bitStream.readBits(6) );
		var unknown = converter.bitsToInteger(bitStream.readBits(5) ); // ?
		var wisdom = converter.bitsToInteger(bitStream.readBits(5) );

		var attributes = new CharacterAttributes
		(
			constitution,
			strength,
			wisdom
		);

		return attributes;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class CreatureType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new CreatureType_Instances();
		}

		return this._instances;
	}
}

class CreatureType_Instances
{
	constructor()
	{
		this.PersonsFriends = new CreatureType(1, "Persons-Friends");
		this.PersonsEnemies = new CreatureType(2, "Persons-Enemies");
		this.PersonsNeutral = new CreatureType(3, "Persons-Neutral");
		this.PersonsThieves = new CreatureType(4, "Persons-Thieves");
		this.BeastsHostile 	= new CreatureType(5, "Beasts-Hostile");
		this.BeastsNeutral 	= new CreatureType(6, "Beasts-Neutral");
		this.EvilBeings 	= new CreatureType(7, "Evil Beings");
		this.YourNewIdea 	= new CreatureType(8, "Your New Idea");

		this._All =
		[
			this.PersonsFriends,
			this.PersonsEnemies,
			this.PersonsNeutral,
			this.PersonsThieves,
			this.BeastsHostile,
			this.BeastsNeutral,
			this.EvilBeings,
			this.YourNewIdea,
		];
	}
}

class Message
{
	constructor(id, text)
	{
		this.id = id;
		this.text = text;
	}
}

class MusicalTheme
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	Instances()
	{
		if (this._instances == null)
		{
			this._instances = new MusicalTheme_Instances();
		}
		return this._instances;
	}
}

class MusicalTheme_Instances
{
	constructor()
	{
		this.Fantasy = new MusicalTheme("Fantasy");
		this.SciFi = new MusicalTheme("SciFi");
		this.Spy = new MusicalTheme("Spy");

		this._All =
		[
			this.Fantasy,
			this.SciFi,
			this.Spy
		];
	}
}

class Picture
{
	constructor(id, pixelColorIndexRows)
	{
		this.id = id;
		this.pixelColorIndexRows = pixelColorIndexRows;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Region
{
	constructor(id, name, rooms)
	{
		this.id = id;
		this.name = name;
		this.rooms = rooms;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);

		var regionId = -1; // todo
		var regionName = reader.readString(20);

		var rooms = [];

		var region = new Region(regionId, regionName, rooms);

		return region;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Room
{
	constructor(id, name, roomMap)
	{
		this.id = id;
		this.name = name;
		this.roomMap = roomMap;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMap
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMapCell
{
	constructor()
	{
		// todo
	}
}

class Thing
{
	constructor
	(
		id,
		name,
		typeId,
		countGeneratedMax,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage,
		isMagic,
		othersCanUse,
		pictureId,
		disappearsOnUse,
		weight,
		value
	)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.countGeneratedMax = countGeneratedMax;
		this.attackAdjustmentAsPercentage = attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage = chanceOfBreakingAsPercentage;
		this.isMagic = isMagic;
		this.othersCanUse = othersCanUse;
		this.pictureId = pictureId;
		this.disappearsOnUse = disappearsOnUse;
		this.weight = weight;
		this.value = value;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var nameEncodedAsBytes = reader.readBytes(10);
		var textDecoder = TextDecoder.Instance();
		var name = textDecoder.stringDecode(nameEncodedAsBytes);
		var typeId = "todo";

		reader.byteIndexSetByteIndex(0x1C000);
		var countGeneratedMax =
			converter.bitStringToInteger(reader.readBits(4) );

		reader.byteIndexSetByteIndex(0x1C087);
		var power = converter.bitsToInteger(reader.readBits(5) );
		var range = converter.bitsToInteger(reader.readBits(5) );
		var attackAdjustmentEncoded =
			converter.bitsToInteger(reader.readBits(4) );
		var chanceOfBreakingAsPercentage =
			converter.bitsToInteger(reader.readBits(4) );
		var isMagic = reader.readBit();
		var onlyOwnerCanUse = reader.readBit();
		var pictureId = reader.readBits(6);
		reader.byteIndexSet(0x1BD00);
		var diesOnUse = reader.readBit();
		var weightEncoded = reader.readBits(15);
		var valueEncoded = reader.readBits(16);

		return new Thing
		(
			-1, // id - todo
			name,
			typeId,
			countGeneratedMax,
			attackAdjustmentAsPercentage,
			chanceOfBreakingAsPercentage,
			isMagic,
			othersCanUse,
			pictureId,
			disappearsOnUse,
			weight,
			value
		);
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class ThingType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new ThingType_Instances();
		}

		return this._instances;
	}
}

class ThingType_Instances
{
	constructor()
	{
		this.Armor			= new ThingType(1, "Armor");
		this.MagicItems		= new ThingType(2, "Magic Items");
		this.MeleeWeapons	= new ThingType(3, "Melee Weapons");
		this.MissileWeapons = new ThingType(4, "Missile Weapons");
		this.MagicSpells	= new ThingType(5, "Magic Spells");
		this.Treasure		= new ThingType(6, "Treasure");

		this._All =
		[
			this.Armor,
			this.MagicItems,
			this.MeleeWeapons,
			this.MissileWeapons,
			this.MagicSpells,
			this.Treasure
		];
	}
}

class WorldMap
{
	constructor(name, terrains, cellsAsTerrainIdRows)
	{
		this.name = name;
		this.terrains = terrains;
		this.cellsAsTerrainIdRows = cellsAsTerrainIdRows;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);

		var worldMap = new worldMap
		(
			name,
			null, // terrains,
			null // cellsAsTerrainIdRows
		);

		return worldMap;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class WorldMapTerrain
{
	constructor(id, name, passability)
	{
		this.id = id;
		this.name = name;
		this.passability = passability;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}

}

class WorldMapTerrainPassability
{
	constructor()
	{
		// todo
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}



</script>