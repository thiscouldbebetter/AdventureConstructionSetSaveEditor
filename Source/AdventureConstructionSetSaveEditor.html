<html>
<body>

<div id="divUi">

	<h3>_Adventure Construction Set_ Save Editor</h3>

	<p>
		Upload an ADVEN.HRD file from the classic DOS-era game
		_Adventure Construction Set_ to see a text representation
		of its contents.  Some samples are provided
		<a href="../Demo/index.html">here</a>.
	</p>

	<div>
		<label>Adventure as JSON:</label>
		<input
			id="inputFile"
			type="file"
			onchange="UiEventHandler.inputFile_Changed(this)"
		></input>
		<br />
		<textarea
			id="textareaJson"
			cols="80" rows="25"
			spellcheck="false"
		></textarea>
	</div>
	<div>
		<button onclick="UiEventHandler.buttonSave_Clicked()">
			Save to File
		</button>
	</div>
</div>

<script type="text/javascript" src="BitHandling/Source/BitStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteConverter.js"></script>

<script type="text/javascript" src="BitHandling/Source/_Imports.js"></script>

<script type="text/javascript" src="TextDecoder.js"></script>

<script type="text/javascript">

class UiEventHandler
{
	static buttonSave_Clicked()
	{
		alert("Not yet implemented!");
	}

	static inputFile_Changed(inputFile)
	{
		var file = inputFile.files[0];
		if (file != null)
		{
			var fileReader = new FileReader();
			fileReader.onload = (event) =>
			{
				var adventureAsBinaryString =
					event.target.result;
				var adventureAsBytes =
					adventureAsBinaryString.split("").map(x => x.charCodeAt(0) );
				var adventure =
					Adventure.fromBytes(adventureAsBytes);
				var adventureAsJson = adventure.toJson();
				var d = document;
				var textareaJson =
					d.getElementById("textareaJson");
				textareaJson.value = adventureAsJson;
			};
			fileReader.readAsBinaryString(file);
		}
	}
}

// Classes.

class Adventure
{
	constructor
	(
		name,
		authorName,
		musicalThemeId,
		pictures,
		worldMap,
		regions,
		things,
		creatures,
		messages
	)
	{
		this.name = name;
		this.authorName = authorName;
		this.musicalThemeId = musicalThemeId;
		this.pictures = pictures;
		this.worldMap = worldMap;
		this.regions = regions;
		this.things = things;
		this.creatures = creatures;
		this.messages = messages;
	}

	pictureByIndex(pictureIndex)
	{
		return this.pictures[pictureIndex];
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var textDecoder = TextDecoder.Instance();
		var converter = new ByteConverter();

		var reader = BitStream.fromBytes(bytes);

		var messagesOffsetInBytes = 0x16C00;
		var messageSizeInBytes = 0x100;
		var messagesSoFar = [];
		var messagesCount = 255; // todo
		reader.byteIndexSet(messagesOffsetInBytes);
		for (var m = 0; m < messagesCount; m++)
		{
			var messageAsBytes =
				reader.readBytes(messagesOffsetInBytes);
			var message = converter.bytesToString(messageAsBytes);
			messagesSoFar.push(message);
		}

		var thingNamesOffsetInBytes = 0x1B800;
		var thingNameSizeInBytes = 10;
		var thingsCount = 100; // ?

		var thingNamesSoFar = [];
		for (var t = 0; t < thingsCount; t++)
		{
			var thingNameEncodedAsBytes =
				reader.readBytes(thingNameSizeInBytes);
			var thingName =
				textDecoder.bytesDecodeToString(thingNameEncodedAsBytes);
			thingNamesSoFar.push(thingName);
		}

		var thingsOffsetInBytes = 0x1C000; // ?
		reader.byteIndexSet(thingsOffsetInBytes);
		var thingsSoFar = [];
		var thingSizeInBytes = 4096; // ?
		for (var t = 0; t < thingsCount; t++)
		{
			var thingId = t + 1;
			var thingName = thingNamesSoFar[t];
			var thingAsBytes = reader.readBytes(thingSizeInBytes);
			var thing = Thing.fromIdNameAndBytes
			(
				thingId, thingName, thingAsBytes
			);
			thingsSoFar.push(thing);
		}

		var adventureNameOffsetInBytes = 0x1C200;
		reader.byteIndexSet(adventureNameOffsetInBytes);
		var adventureName = converter.bytesToString(reader.readBytes(14) );
		var authorName = converter.bytesToString(reader.readBytes(14) );

		reader.byteIndexSet(0x1C229);
		var regionCount = reader.readByte();
		var regionsSoFar = [];
		var regionsOffsetInBytes = 0x1C441;
		var regionSizeInBytes = 0x200;
		reader.byteIndexSet(regionsOffsetInBytes);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var regionAsBytes = reader.readBytes(regionSizeInBytes);
			var region = Region.fromBytes(regionAsBytes);
			regionsSoFar.push(region);
		}

		var worldMapOffsetInBytes = 0x1C000; // hack
		reader.byteIndexSet(worldMapOffsetInBytes);
		var worldMapSizeInBytes = 0x1000; // todo
		var worldMapAsBytes = reader.readBytes(worldMapSizeInBytes);
		var worldMap = WorldMap.fromBytes(worldMapAsBytes);

		reader.byteIndexSet(0x1C56e);
		var musicalThemeId = reader.readByte();

		var creaturesOffsetInBytes = 0x1CB0A;
		var creatureSizeInBytes = 0x300; // todo
		var creaturesCount = 100; // todo
		var creaturesSoFar = [];
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureAsBytes = reader.readBytes(creatureSizeInBytes);
			var creature = Creature.fromBytes(creatureAsBytes);
			creaturesSoFar.push(creature);
		}

		var pictures = [];
		var picturesCount = 128; // ?
		for (var p = 0; p < picturesCount; p++)
		{
			var picture = Picture.fromId(p);
			pictures.push(picture);
		}

		var pictureSizeInPixels =
			Picture.sizeInPixels(); // 16 x 16 pixels.
		var picturePixelCount =
			pictureSizeInPixels.x
			* pictureSizeInPixels.y;
		var bitsPerPixel = 2;
		var pictureSizeInBits =
			picturePixelCount * bitsPerPixel;
		var pictureSizeInBytes =
			pictureSizeInBits / 8;
		var pictureQuadrantSizeInBytes =
			pictureSizeInBytes / 4;

		var picture0OffsetInBytes = 0x28720; // ?
		reader.byteIndexSet(picture0OffsetInBytes);

		// 4x1 tetrads of pixels
		// are encoded as individual bytes.
		// The order of tetrads, in bytes offset from
		// the 0th tetrad, are:
		//	0...----8...----
		//	1...----9...----
		//	2...----a...----
		//	3...----b...----
		//	4...----c...----
		//	5...----d...----
		//	6...----e...----
		//	7...----f...----
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		// The next byte encodes the upper-left
		// tetrad of pixels of the subsequent picture!
		// Assuming that it'll do those two columns of tetrads
		// in every picture next,
		// that's 16 bytes,
		// and there are 128 pictures(?),
		// so if we advance 16 x 128 = 2,048 bytes,
		// then we'll return to the next tetrad of pixels
		// in THIS picture.
		// Maybe it'll be the upper-left pixel
		// of the left half
		// of the lower-left quadrant?
		// That position is, uh, 28F30,
		// which is 2,048 bytes from the first,
		// upper-left byte of the picture.

		var octantPairOffsetWithinPictureInPixels = new Coords(0, 0);
		var octantOffsetWithinPairInPixels = new Coords(0, 0);
		var octantPosInPixels = new Coords(0, 0);
		var tetradOffsetWithinOctantInPixels = new Coords(0, 0);
		var pixelPosInPixels = new Coords(0, 0);
		var pixelsPerTetrad = 4;
		var octantsPerOctantPair = 2;
		var octantSizeInTetrads = 8;

		for (var octantPairIndex = 0; octantPairIndex < 4; octantPairIndex++)
		{
			if (octantPairIndex == 2)
			{
				// I don't know why this jump is needed,
				// or what lies in between.
				reader.byteIndexSet(0x2AB20);
			}

			octantPairOffsetWithinPictureInPixels.y =
				(octantPairIndex  % 2)
				* pictureSizeInPixels.y / 2;

			octantPairOffsetWithinPictureInPixels.x =
				Math.floor(octantPairIndex  / 2)
				* pictureSizeInPixels.x / 4;

			for (var p = 0; p < picturesCount; p++)
			{
				var picture = pictures[p];

				for (var octantIndexWithinPair = 0; octantIndexWithinPair < octantsPerOctantPair; octantIndexWithinPair++)
				{
					octantOffsetWithinPairInPixels.x =
						octantIndexWithinPair * pictureSizeInPixels.x / 2;

					octantPosInPixels.x =
						octantPairOffsetWithinPictureInPixels.x
						+ octantOffsetWithinPairInPixels.x;

					for (var ty = 0; ty < octantSizeInTetrads; ty++)
					{
						tetradOffsetWithinOctantInPixels.y = ty;

						pixelPosInPixels.y =
							octantPairOffsetWithinPictureInPixels.y
							+ octantOffsetWithinPairInPixels.y
							+ tetradOffsetWithinOctantInPixels.y;

						for (var i = 0; i < pixelsPerTetrad; i++)
						{
							var iReversed = pixelsPerTetrad - i - 1;

							pixelPosInPixels.x =
								octantPosInPixels.x
								+ iReversed;

							var pixelColorIndex =
								reader.readIntegerFromBits(2);

							picture.pixelAtPosSetToColorIndex
							(
								pixelPosInPixels,
								pixelColorIndex
							);
						}
					}
				}
			}
		}

		var d = document;
		var divPictures = d.createElement("div");
		for (var p = 0; p < picturesCount; p++)
		{
			var picture = pictures[p];
			var pictureAsCanvas = picture.toCanvas();
			divPictures.appendChild(pictureAsCanvas);
		}
		d.body.appendChild(divPictures);

		var adventure = new Adventure
		(
			adventureName,
			authorName,
			musicalThemeId,
			pictures,
			worldMap,
			regionsSoFar,
			thingsSoFar,
			creaturesSoFar,
			messagesSoFar
		);

		var worldMapAsCanvas =
			worldMap.toCanvas(adventure);
		d.body.appendChild(worldMapAsCanvas);

		return adventure;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Json.

	fromJson()
	{
		throw new Error("todo");
	}

	toJson()
	{
		return "todo"; // JSON.stringify(this, null, 4);
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static fromXY(x, y)
	{
		return new Coords(x, y);
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	toString()
	{
		return this.x + "x" + this.y;
	}
}

class Creature
{
	constructor(id, name, typeId, attributes, other)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.attributes = attributes;
		this.other = other;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var reader = ByteStream.fromBytes(bytes);

		var id = -1; // todo
		var name = "todo";
		var typeId = -1; // todo
		var attributesAsBytes = reader.readBytes(10);
		var attributes =
			CreatureAttributes.fromBytes(attributesAsBytes);
		var other = reader.readBytes(0); // todo

		var creature = new Creature
		(
			id,
			name,
			typeId,
			attributes,
			other
		);

		return creature;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class CreatureAttributes
{
	constructor(constitution, unknown, wisdom)
	{
		this.constitution = constitution;
		this.unknown = unknown;
		this.wisdom = wisdom;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var bitStream = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var constitution = bitStream.readIntegerFromBits(6);
		var strength = bitStream.readIntegerFromBits(5);
		var wisdom = bitStream.readIntegerFromBits(5);

		var attributes = new CreatureAttributes
		(
			constitution,
			strength,
			wisdom
			// todo
		);

		return attributes;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class CreatureType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new CreatureType_Instances();
		}

		return this._instances;
	}
}

class CreatureType_Instances
{
	constructor()
	{
		this.PersonsFriends = new CreatureType(1, "Persons-Friends");
		this.PersonsEnemies = new CreatureType(2, "Persons-Enemies");
		this.PersonsNeutral = new CreatureType(3, "Persons-Neutral");
		this.PersonsThieves = new CreatureType(4, "Persons-Thieves");
		this.BeastsHostile 	= new CreatureType(5, "Beasts-Hostile");
		this.BeastsNeutral 	= new CreatureType(6, "Beasts-Neutral");
		this.EvilBeings 	= new CreatureType(7, "Evil Beings");
		this.YourNewIdea 	= new CreatureType(8, "Your New Idea");

		this._All =
		[
			this.PersonsFriends,
			this.PersonsEnemies,
			this.PersonsNeutral,
			this.PersonsThieves,
			this.BeastsHostile,
			this.BeastsNeutral,
			this.EvilBeings,
			this.YourNewIdea,
		];
	}
}

class Message
{
	constructor(id, text)
	{
		this.id = id;
		this.text = text;
	}
}

class MusicalTheme
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	Instances()
	{
		if (this._instances == null)
		{
			this._instances = new MusicalTheme_Instances();
		}
		return this._instances;
	}
}

class MusicalTheme_Instances
{
	constructor()
	{
		this.Fantasy = new MusicalTheme("Fantasy");
		this.SciFi = new MusicalTheme("SciFi");
		this.Spy = new MusicalTheme("Spy");

		this._All =
		[
			this.Fantasy,
			this.SciFi,
			this.Spy
		];
	}
}

class Picture
{
	constructor(id, pixelColorIndexRows)
	{
		this.id = id;
		this.pixelColorIndexRows =
			pixelColorIndexRows;
		if (this.pixelColorIndexRows == null)
		{
			var size = Picture.sizeInPixels();
			this.pixelColorIndexRows = [];
			for (var y = 0; y < size.y; y++)
			{
				var pixelColorIndexRow = [];
				for (var x = 0; x < size.x; x++)
				{
					pixelColorIndexRow.push(0);
				}
				this.pixelColorIndexRows.push(pixelColorIndexRow);
			}
		}
	}

	static fromId(id)
	{
		return new Picture(id, null);
	}

	static sizeInPixels()
	{
		if (this._sizeInPixels == null)
		{
			this._sizeInPixels = Coords.fromXY(16, 16);
		}
		return this._sizeInPixels;
	}

	pixelAtPosGetColorIndex(pixelPos)
	{
		return this.pixelColorIndexRows[pixelPos.y][pixelPos.x];
	}

	pixelAtPosSetToColorIndex(pixelPos, colorIndex)
	{
		var row = this.pixelColorIndexRows[pixelPos.y];
		row[pixelPos.x] = colorIndex;
	}

	toCanvas()
	{
		if (this._canvas == null)
		{
			var colorsByIndex = // hack - Palette colors might be modified.
			[
				"Black",
				"Blue",
				"Brown",
				"White"
			];
		
			var d = document;
			var canvas = d.createElement("canvas");
			var pictureSizeInPixels = Picture.sizeInPixels();
			canvas.width = pictureSizeInPixels.x;
			canvas.height = pictureSizeInPixels.y;
			var g = canvas.getContext("2d");

			var pixelPosInPixels = new Coords();
			for (var py = 0; py < pictureSizeInPixels.y; py++)
			{
				pixelPosInPixels.y = py;
				for (var px = 0; px < pictureSizeInPixels.x; px++)
				{
					pixelPosInPixels.x = px;
					var pixelColorIndex =
						this.pixelAtPosGetColorIndex(pixelPosInPixels);
					var pixelColor =
						colorsByIndex[pixelColorIndex];
					g.fillStyle = pixelColor;
					g.fillRect(pixelPosInPixels.x, pixelPosInPixels.y, 1, 1);
				}
			}

			this._canvas = canvas;
		}

		return this._canvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var id = "todo";
		var bitStream = BitStream.fromBytes(bytes);
		var pixelColorIndexRows = [];
		var pictureDimensionInPixels = 16;
		var pixelColorIndexRows = [];
		for (var y = 0; y < pictureDimensionInPixels; y++)
		{
			var pixelColorIndicesForRow = [];

			for (var x = 0; x < pictureDimensionInPixels; x++)
			{
				var pixelColorIndex = bitStream.readIntegerFromBits(2);
				pixelColorIndicesForRow.push(pixelColorIndex);
			}

			pixelColorIndexRows.push(pixelColorIndicesForRow);
		}

		var picture = new Picture(id, pixelColorIndexRows);

		return picture;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Region
{
	constructor(id, name, rooms)
	{
		this.id = id;
		this.name = name;
		this.rooms = rooms;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);

		var regionId = -1; // todo
		var regionName = reader.readString(20);

		var rooms = [];

		var region = new Region(regionId, regionName, rooms);

		return region;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Room
{
	constructor(id, name, roomMap)
	{
		this.id = id;
		this.name = name;
		this.roomMap = roomMap;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMap
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMapCell
{
	constructor()
	{
		// todo
	}
}

class Thing
{
	constructor
	(
		id,
		name,
		typeId,
		countGeneratedMax,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage,
		isMagic,
		othersCanUse,
		pictureId,
		disappearsOnUse,
		weight,
		value
	)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.countGeneratedMax = countGeneratedMax;
		this.attackAdjustmentAsPercentage = attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage = chanceOfBreakingAsPercentage;
		this.isMagic = isMagic;
		this.othersCanUse = othersCanUse;
		this.pictureId = pictureId;
		this.disappearsOnUse = disappearsOnUse;
		this.weight = weight;
		this.value = value;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromIdNameAndBytes(id, name, bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var typeId = "todo";

		//reader.byteIndexSetByteIndex(0x1C000);
		var countGeneratedMax =
			reader.readIntegerFromBits(4);

		//reader.byteIndexSetByteIndex(0x1C087);
		var power = reader.readIntegerFromBits(5);
		var range = reader.readIntegerFromBits(5);
		var attackAdjustmentEncoded =
			reader.readIntegerFromBits(4);
		var attackAdjustmentAsPercentage = 
			attackAdjustmentEncoded * 5 - 40;
		var chanceOfBreakingAsPercentage =
			reader.readIntegerFromBits(4);
		var isMagic = (reader.readBit() > 0);
		var onlyOwnerCanUse = (reader.readBit() > 0);
		var pictureId = reader.readIntegerFromBits(6);

		//reader.byteIndexSet(0x1BD00);
		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		return new Thing
		(
			id,
			name,
			typeId,
			countGeneratedMax,
			attackAdjustmentAsPercentage,
			chanceOfBreakingAsPercentage,
			isMagic,
			onlyOwnerCanUse,
			pictureId,
			diesOnUse,
			weight,
			value
		);
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class ThingType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new ThingType_Instances();
		}

		return this._instances;
	}
}

class ThingType_Instances
{
	constructor()
	{
		this.Armor			= new ThingType(1, "Armor");
		this.MagicItems		= new ThingType(2, "Magic Items");
		this.MeleeWeapons	= new ThingType(3, "Melee Weapons");
		this.MissileWeapons = new ThingType(4, "Missile Weapons");
		this.MagicSpells	= new ThingType(5, "Magic Spells");
		this.Treasure		= new ThingType(6, "Treasure");

		this._All =
		[
			this.Armor,
			this.MagicItems,
			this.MeleeWeapons,
			this.MissileWeapons,
			this.MagicSpells,
			this.Treasure
		];
	}
}

class WorldMap
{
	constructor
	(
		name,
		wrappingIsAllowed,
		entryPoint,
		terrainDefinitions,
		creatureOccurrences,
		sizeInCells,
		cellsAsTerrainIndexRows
	)
	{
		this.name = name;
		this.wrappingIsAllowed = wrappingIsAllowed;
		this.entryPoint = entryPoint;
		this.terrainDefinitions = terrainDefinitions;
		this.creatureOccurrences = creatureOccurrences;
		this.sizeInCells = sizeInCells;
		this.cellsAsTerrainIndexRows = cellsAsTerrainIndexRows;
	}

	terrainAtPosInCells(posInCells)
	{
		var terrainIndex =
			this.terrainIndexAtPosInCells(posInCells);
		var terrain = this.terrainDefinitions[terrainIndex];
		return terrain;
	}

	terrainIndexAtPosInCells(posInCells)
	{
		var cellTerrainIndexRow =
			this.cellsAsTerrainIndexRows[posInCells.y];
		var cellTerrainIndex =
			cellTerrainIndexRow[posInCells.x];
		return cellTerrainIndex;
	}

	toCanvas(adventure)
	{
		var d = document;

		var mapSizeInCells = this.sizeInCells;
		var pictureSizeInPixels = Picture.sizeInPixels();
		var cellSizeInPixels = pictureSizeInPixels;
		var mapSizeInPixels =
			mapSizeInCells
				.clone()
				.multiply(cellSizeInPixels);

		var mapAsCanvas = d.createElement("canvas");
		mapAsCanvas.width = mapSizeInPixels.x;
		mapAsCanvas.height = mapSizeInPixels.y;
		var graphics = mapAsCanvas.getContext("2d");

		var cellPosInCells = new Coords(0, 0);
		var drawPosInPixels = new Coords(0, 0);
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < mapSizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellTerrain =
					this.terrainAtPosInCells(cellPosInCells);

				drawPosInPixels
					.overwriteWith(cellPosInCells)
					.multiply(cellSizeInPixels);

				var cellTerrainPicture =
					cellTerrain.picture(adventure);
				var cellTerrainPictureAsCanvas =
					cellTerrainPicture.toCanvas();

				graphics.drawImage
				(
					cellTerrainPictureAsCanvas,
					drawPosInPixels.x, drawPosInPixels.y
				);
			}
		}

		return mapAsCanvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		// Start with 0x1C000.

		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		reader.byteIndexSet(0x42C);
		var wrappingIsAllowed =
			reader.readByte() > 0;

		var name =
			converter.bytesToString(reader.readBytes(20) );

		reader.byteIndexSet(0x700 + 234); // hack
		var mapSizeInCells = new Coords(40, 40);
		var bitsPerCell = 4; // 16 terrains.
		var mapCellsCount =
			mapSizeInCells.x
			* mapSizeInCells.y;
		var bitsPerByte = 8;
		var mapCellsSizeInBytes =
			mapCellsCount * bitsPerCell / bitsPerByte;
		var mapCellPairsAsBytes =
			reader.readBytes(mapCellsSizeInBytes);
		var terrainIndicesForCells = [];
		for (var i = 0; i < mapCellPairsAsBytes.length; i++)
		{
			var cellPairAsByte = mapCellPairsAsBytes[i];
			var cellLeftTerrainIndex =
				cellPairAsByte >> 4;
			var cellRightTerrainIndex =
				cellPairAsByte & 0x0F;
			terrainIndicesForCells.push(cellLeftTerrainIndex);
			terrainIndicesForCells.push(cellRightTerrainIndex);
		}

		var cellsAsTerrainIndexRows = [];
		var cellsPerRow = mapSizeInCells.x;
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			var cellIndexStart = y * cellsPerRow;
			var cellIndexEnd =
				cellIndexStart + cellsPerRow;

			var terrainIndexRow =
				terrainIndicesForCells
					.slice(cellIndexStart, cellIndexEnd);
			cellsAsTerrainIndexRows
				.push(terrainIndexRow);
		}

		reader.byteIndexSet(0x7a0);
		var playerEntryPoint = new Coords
		(
			reader.readByte(), reader.readByte()
		);

		var td = (id, name) => new WorldMapTerrain(id, name, id, null);
		var terrainDefinitions =
		[
			td(0,	"Water"),
			td(1,	"Plain"),
			td(2,	"Swamp"),
			td(3,	"Desert"),
			td(4,	"Dense Forest"),
			td(5,	"Forest"),
			td(6,	"Chapparal"),
			td(7,	"Fields"),
			td(8,	"Mountains"),
			td(9,	"Foothills"),
			td(10,	"River"),
			td(11,	"High Mountains"),
			td(12,	"Gateway"),
			td(13,	"Parapet Gateway"),
			td(14,	"Castle"),
			td(15,	"Old Church")
		];

		var creatureOccurrences = []; // todo
		/*
		reader.byteIndexSet(0xb0a);
		var creatureOccurrenceSizeInBytes = 592; // ?
		var creatureOccurrencesCount = 8;
		for (var i = 0; i < creatureOccurrencesCount; i++)
		{
			var creatureOccurrenceAsBytes =
				reader.readBytes(creatureOccurrenceSizeInBytes);
		}
		*/

		var worldMap = new WorldMap
		(
			name,
			wrappingIsAllowed,
			playerEntryPoint,
			terrainDefinitions,
			creatureOccurrences,
			mapSizeInCells,
			cellsAsTerrainIndexRows
		);

		return worldMap;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class WorldMapCreatureOccurrence
{}

class WorldMapTerrain
{
	constructor(id, name, pictureIndex, passability)
	{
		this.id = id;
		this.name = name;
		this.pictureIndex = pictureIndex;
		this.passability = passability;
	}

	picture(adventure)
	{
		return adventure.pictureByIndex(this.pictureIndex);
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}

}

class WorldMapTerrainPassability
{
	constructor()
	{
		// todo
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}



</script>