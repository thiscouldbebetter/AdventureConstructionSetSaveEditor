<html>
<body>

<div id="divUi">

	<h3>_Adventure Construction Set_ Save Editor</h3>

	<p>
		Upload an ADVEN.HRD file from the classic DOS-era game
		_Adventure Construction Set_ to see a text representation
		of its contents.  Some samples are provided
		<a href="../Demo/index.html">here</a>.
	</p>

	<div>
		<label>Adventure File:</label>
		<input
			id="inputFile"
			type="file"
			onchange="UiEventHandler.inputFile_Changed(this)"
		></input>
	</div>

	<div>
		<button
			onclick="UiEventHandler.buttonSelect_Clicked()"
		>
			Select:
		</button>
		<select
			id="selectObjectToDrawType"
		>
			<option>Creature</option>
			<option>Picture</option>
			<option>Region</option>
			<option>Room</option>
			<option>Thing</option>
			<option>World Map</option>
		</select>
		<label>with ID:</label>
		<input
			id="inputObjectToDrawId"
			type="number"
			min="0" max="128"
			value="1"
		></input>
		<div id="divObjectToDraw">
			[nothing drawn yet]
		</div>
	</div>

	<div>
		<label>Object Selected as JSON:</label>
		<br />
		<textarea
			id="textareaJson"
			cols="80" rows="25"
			spellcheck="false"
		></textarea>
	</div>
	<div>
		<button onclick="UiEventHandler.buttonSave_Clicked()">
			Save to File
		</button>
	</div>
</div>

<script type="text/javascript" src="BitHandling/Source/BitStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteConverter.js"></script>

<script type="text/javascript" src="BitHandling/Source/_Imports.js"></script>

<script type="text/javascript" src="TextDecoder.js"></script>

<script type="text/javascript">

class UiEventHandler
{
	static _adventureLoaded;
	static adventureLoaded()
	{
		return this._adventureLoaded;
	}

	static adventureLoadedSet(value)
	{
		this._adventureLoaded = value;
	}

	static buttonSave_Clicked()
	{
		alert("Not yet implemented!");
	}

	static buttonSelect_Clicked()
	{
		var d = document;

		var divObjectToDraw =
			d.getElementById("divObjectToDraw");
		divObjectToDraw.innerHTML = "";
		var textareaJson =
			d.getElementById("textareaJson");
		textareaJson.value = "[none]";

		var adventure = this.adventureLoaded();
		if (adventure == null)
		{
			divObjectToDraw.innerHTML =
				"[nothing to draw yet]";
		}
		else
		{
			var selectObjectToDrawType =
				d.getElementById("selectObjectToDrawType");
			var inputObjectToDrawId =
				d.getElementById("inputObjectToDrawId");

			var objectToDrawTypeName =
				selectObjectToDrawType.value;
			var objectToDrawId =
				parseInt(inputObjectToDrawId.value);

			if (objectToDrawTypeName == "Creature")
			{
				if (objectToDrawId == 0)
				{
					var creatures = adventure.creatures;
					var creaturesAsCanvases =
						creatures.map(x => x.toCanvas(adventure) );
					divObjectToDraw.appendChild(...creaturesAsCanvases);
					var creaturesAsJson =
						Creature.manyToJson(creatures);
					textareaJson.value = creaturesAsJson;
				}
				else
				{
					var creature =
						adventure.creatureById(objectToDrawId);
					var creatureAsCanvas =
						creature.toCanvas(adventure);
					divObjectToDraw.appendChild(creatureAsCanvas);
					var creatureAsJson = creature.toJson();
					textareaJson.value = creatureAsJson;
				}
			}
			else if (objectToDrawTypeName == "Picture")
			{
				var pictures = adventure.pictures;

				if (objectToDrawId == 0)
				{
					for (var p = 0; p < pictures.length; p++)
					{
						var picture = pictures[p];
						var pictureAsCanvas = picture.toCanvas();
						divObjectToDraw.appendChild(pictureAsCanvas);
					}
					var picturesAsJson = Picture.manyToJson(pictures);
					textareaJson.value = picturesAsJson;
				}
				else
				{
					var picture = pictures[objectToDrawIndex];
					var pictureAsCanvas = picture.toCanvas();
					divObjectToDraw.appendChild(pictureAsCanvas);
					var pictureAsJson = picture.toJson();
					textareaJson.value = pictureAsJson;
				}
			}
			else if (objectToDrawTypeName == "Region")
			{
				var region = adventure.regionsById(objectToDrawId);
				var regionAsCanvas = region.toCanvas();
				divObjectToDraw.appendChild(regionAsCanvas);
				var regionAsJson = region.toJson();
				textareaJson.value = regionAsJson;
			}
			else if (objectToDrawTypeName == "Room")
			{
				alert("todo");
			}
			else if (objectToDrawTypeName == "Thing")
			{
				alert("todo");
			}
			else if (objectToDrawTypeName == "World Map")
			{
				var worldMap = adventure.worldMap;
				var worldMapAsCanvas =
					worldMap.toCanvas(adventure);
				divObjectToDraw.appendChild(worldMapAsCanvas);
			}
			else
			{
				throw new Error("Unrecognized!");
			}
		}
	}

	static inputFile_Changed(inputFile)
	{
		var file = inputFile.files[0];
		if (file != null)
		{
			var fileReader = new FileReader();
			fileReader.onload = (event) =>
			{
				var adventureAsBinaryString =
					event.target.result;
				var adventureAsBytes =
					adventureAsBinaryString.split("").map(x => x.charCodeAt(0) );
				var adventure =
					Adventure.fromBytes(adventureAsBytes);

				UiEventHandler.adventureLoadedSet(adventure);

				var adventureAsJson = adventure.toJson();

				var d = document;
				var textareaJson =
					d.getElementById("textareaJson");
				textareaJson.value = adventureAsJson;
			};
			fileReader.readAsBinaryString(file);
		}
	}
}

// Classes.

class Adventure
{
	constructor
	(
		name,
		authorName,
		musicalThemeId,
		pictures,
		worldMap,
		regions,
		things,
		creatures,
		messages
	)
	{
		this.name = name;
		this.authorName = authorName;
		this.musicalThemeId = musicalThemeId;
		this.pictures = pictures;
		this.worldMap = worldMap;
		this.regions = regions;
		this.things = things;
		this.creatures = creatures;
		this.messages = messages;
	}

	creatureById(creatureId)
	{
		var creatureIndex = creatureId - 1;
		return this.creatures[creatureIndex];
	}

	pictureById(pictureId)
	{
		return this.pictureByIndex(pictureId - 1);
	}

	pictureByIndex(pictureIndex)
	{
		return this.pictures[pictureIndex];
	}

	regionById(regionId)
	{
		var regionIndex = regionId - 1;
		return this.regions[regionIndex];
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var textDecoder = TextDecoder.Instance();
		var converter = new ByteConverter();

		var reader = BitStream.fromBytes(bytes);

		var messagesOffsetInBytes = 0x16C00;
		var messageSizeInBytes = 0x100;
		var messages = [];
		var messagesCount = 255; // todo
		reader.byteIndexSet(messagesOffsetInBytes);
		for (var m = 0; m < messagesCount; m++)
		{
			var messageAsBytes =
				reader.readBytes(messagesOffsetInBytes);
			var message = converter.bytesToString(messageAsBytes);
			messages.push(message);
		}

		var things =
			this.fromBytes_Things(reader, converter, textDecoder);

		var creatures =
			this.fromBytes_Creatures(reader, converter, textDecoder);

		var adventureNameOffsetInBytes = 0x1C200;
		reader.byteIndexSet(adventureNameOffsetInBytes);
		var adventureName = converter.bytesToString(reader.readBytes(14) );
		var authorName = converter.bytesToString(reader.readBytes(14) );

		//reader.byteIndexSet(0x1C229);
		var regionCount = reader.readByte();
		var regions = [];
		var regionNamesOffsetInBytes = 0x1C441;
		var regionNameSizeInBytes = 20;
		reader.byteIndexSet(regionNamesOffsetInBytes);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var regionNameAsBytes =
				reader.readBytes(regionNameSizeInBytes);
			var regionName =
				converter.bytesToString(regionNameAsBytes);
			var region = Region.fromIdAndName(rg, regionName);
			regions.push(region);
		}

		//reader.byteIndexSet(todo);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var region = regions[rg];
			var regionRooms = [];
			var roomCount = 10;
			// todo
		}

		var worldMapOffsetInBytes = 0x1C000; // hack
		reader.byteIndexSet(worldMapOffsetInBytes);
		var worldMapSizeInBytes = 0x1000; // todo
		var worldMapAsBytes = reader.readBytes(worldMapSizeInBytes);
		var worldMap = WorldMap.fromBytes(worldMapAsBytes);

		reader.byteIndexSet(0x1C56e);
		var musicalThemeId = reader.readByte();

		var pictures = [];
		var picturesCount = 128; // ?
		for (var p = 0; p < picturesCount; p++)
		{
			var picture = Picture.fromId(p);
			pictures.push(picture);
		}

		var pictureSizeInPixels =
			Picture.sizeInPixels(); // 16 x 16 pixels.
		var picturePixelCount =
			pictureSizeInPixels.x
			* pictureSizeInPixels.y;
		var bitsPerPixel = 2;
		var pictureSizeInBits =
			picturePixelCount * bitsPerPixel;
		var pictureSizeInBytes =
			pictureSizeInBits / 8;
		var pictureQuadrantSizeInBytes =
			pictureSizeInBytes / 4;

		var picture0OffsetInBytes = 0x28720; // ?
		reader.byteIndexSet(picture0OffsetInBytes);

		// 4x1 tetrads of pixels
		// are encoded as individual bytes.
		// The order of tetrads, in bytes offset from
		// the 0th tetrad, are:
		//	0...----8...----
		//	1...----9...----
		//	2...----a...----
		//	3...----b...----
		//	4...----c...----
		//	5...----d...----
		//	6...----e...----
		//	7...----f...----
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		// The next byte encodes the upper-left
		// tetrad of pixels of the subsequent picture!
		// Assuming that it'll do those two columns of tetrads
		// in every picture next,
		// that's 16 bytes,
		// and there are 128 pictures(?),
		// so if we advance 16 x 128 = 2,048 bytes,
		// then we'll return to the next tetrad of pixels
		// in THIS picture.
		// Maybe it'll be the upper-left pixel
		// of the left half
		// of the lower-left quadrant?
		// That position is, uh, 28F30,
		// which is 2,048 bytes from the first,
		// upper-left byte of the picture.

		var octantPairOffsetWithinPictureInPixels = new Coords(0, 0);
		var octantOffsetWithinPairInPixels = new Coords(0, 0);
		var octantPosInPixels = new Coords(0, 0);
		var tetradOffsetWithinOctantInPixels = new Coords(0, 0);
		var pixelPosInPixels = new Coords(0, 0);
		var pixelsPerTetrad = 4;
		var octantsPerOctantPair = 2;
		var octantSizeInTetrads = 8;

		for (var octantPairIndex = 0; octantPairIndex < 4; octantPairIndex++)
		{
			if (octantPairIndex == 2)
			{
				// I don't know why this jump is needed,
				// or what lies in between.
				reader.byteIndexSet(0x2AB20);
			}

			octantPairOffsetWithinPictureInPixels.y =
				(octantPairIndex  % 2)
				* pictureSizeInPixels.y / 2;

			octantPairOffsetWithinPictureInPixels.x =
				Math.floor(octantPairIndex  / 2)
				* pictureSizeInPixels.x / 4;

			for (var p = 0; p < picturesCount; p++)
			{
				var picture = pictures[p];

				for (var octantIndexWithinPair = 0; octantIndexWithinPair < octantsPerOctantPair; octantIndexWithinPair++)
				{
					octantOffsetWithinPairInPixels.x =
						octantIndexWithinPair * pictureSizeInPixels.x / 2;

					octantPosInPixels.x =
						octantPairOffsetWithinPictureInPixels.x
						+ octantOffsetWithinPairInPixels.x;

					for (var ty = 0; ty < octantSizeInTetrads; ty++)
					{
						tetradOffsetWithinOctantInPixels.y = ty;

						pixelPosInPixels.y =
							octantPairOffsetWithinPictureInPixels.y
							+ octantOffsetWithinPairInPixels.y
							+ tetradOffsetWithinOctantInPixels.y;

						for (var i = 0; i < pixelsPerTetrad; i++)
						{
							var iReversed = pixelsPerTetrad - i - 1;

							pixelPosInPixels.x =
								octantPosInPixels.x
								+ iReversed;

							var pixelColorIndex =
								reader.readIntegerFromBits(2);

							picture.pixelAtPosSetToColorIndex
							(
								pixelPosInPixels,
								pixelColorIndex
							);
						}
					}
				}
			}
		}

		var adventure = new Adventure
		(
			adventureName,
			authorName,
			musicalThemeId,
			pictures,
			worldMap,
			regions,
			things,
			creatures,
			messages
		);

		return adventure;
	}

	static fromBytes_Creatures(reader, converter, textDecoder)
	{
		var creatureNamesOffsetInBytes = 0x1B280;
		reader.byteIndexSet(creatureNamesOffsetInBytes);

		var creatureNameSizeInBytes = 10;
		var creaturesCount = 128; // ?

		var creatureNames = [];
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureNameEncodedAsBytes =
				reader.readBytes(creatureNameSizeInBytes);
			var creatureName =
				textDecoder
					.bytesDecodeToString(creatureNameEncodedAsBytes)
					.trim();
			creatureNames.push(creatureName);
		}

		var creaturesDataOffsetInBytes = 0x19400;
		reader.byteIndexSet(creaturesDataOffsetInBytes);
		var creaturesSoFar = [];
		var creatureSizeInBytes = 37; // 0x25.
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureId = c + 1;
			var creatureName = creatureNames[c];
			var creatureAsBytes = reader.readBytes(creatureSizeInBytes);
			var creature = Creature.fromIdNameAndBytes
			(
				creatureId, creatureName, creatureAsBytes
			);
			creaturesSoFar.push(creature);
		}

		return creaturesSoFar;
	}


	static fromBytes_Things(reader, converter, textDecoder)
	{
		var thingNamesOffsetInBytes = 0x1B800;
		var thingNameSizeInBytes = 10;
		var thingsCount = 100; // ?

		var thingNamesSoFar = [];
		for (var t = 0; t < thingsCount; t++)
		{
			var thingNameEncodedAsBytes =
				reader.readBytes(thingNameSizeInBytes);
			var thingName =
				textDecoder.bytesDecodeToString(thingNameEncodedAsBytes);
			thingNamesSoFar.push(thingName);
		}

		var thingsOffsetInBytes = 0x1C000; // ?
		reader.byteIndexSet(thingsOffsetInBytes);
		var thingsSoFar = [];
		var thingSizeInBytes = 4096; // ?
		for (var t = 0; t < thingsCount; t++)
		{
			var thingId = t + 1;
			var thingName = thingNamesSoFar[t];
			var thingAsBytes = reader.readBytes(thingSizeInBytes);
			var thing = Thing.fromIdNameAndBytes
			(
				thingId, thingName, thingAsBytes
			);
			thingsSoFar.push(thing);
		}

		return thingsSoFar;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Json.

	fromJson()
	{
		throw new Error("todo");
	}

	toJson()
	{
		return "todo"; // JSON.stringify(this, null, 4);
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static fromXY(x, y)
	{
		return new Coords(x, y);
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	toString()
	{
		return this.x + "x" + this.y;
	}
}

class Creature
{
	constructor
	(
		id,
		name,
		typeId,
		pictureId,
		attributes,
		strategyId,
		mimicsOpponent,
		equipment
	)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.pictureId = pictureId;
		this.attributes = attributes;
		this.strategyId = strategyId;
		this.mimicsOpponent = mimicsOpponent;
		this.equipment = equipment;
	}

	static fromIdNameAndBytes(id, name, bytes)
	{
		var creature = Creature.fromBytes(bytes);
		creature.id = id;
		creature.name = name;
		return creature;
	}

	picture(adventure)
	{
		return adventure.pictureById(this.pictureId);
	}

	toCanvas(adventure)
	{
		return this.picture(adventure).toCanvas();
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var reader = ByteStream.fromBytes(bytes);

		var id = -1; // todo
		var name = "todo";
		var typeId = -1; // todo
		var pictureId = 1; // todo
		var attributesAsBytes = reader.readBytes(37);
		var attributes =
			CreatureAttributes.fromBytes(attributesAsBytes);
		var strategyId = "todo";
		var mimicsOpponent = false;
		var wealth = "todo";
		var itemsHeld = []; // todo
		var itemReadiedArmor = null; // todo
		var itemReadiedWeapon = null; // todo
		var equipment = new CreatureEquipment
		(
			wealth,
			itemsHeld,
			itemReadiedArmor,
			itemReadiedWeapon
		); // todo

		var creature = new Creature
		(
			id,
			name,
			typeId,
			pictureId,
			attributes,
			strategyId,
			mimicsOpponent,
			equipment
		);

		return creature;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// JSON.

	static manyToJson(creatures)
	{
		var creaturesAsJson =
			creatures.map(x => x.toJson() );
		var creaturesAsJsonJoined =
			creaturesAsJson.join(",\n");
		var returnValue =
			"{\n" + creaturesAsJsonJoined + "\n}";
		return returnValue;
	}

	static fromJson(creatureAsJson)
	{
		throw new Error("todo");
	}

	toJson()
	{
		return JSON.stringify(this, null, 4);
	}
}

class CreatureAttributes
{
	constructor
	(
		constitution,
		strength,
		dexterity,
		wisdom,
		size,

		lifeForce,
		power,
		speed, // action points?

		missileSkill,
		meleeSkill,
		armorSkill,
		dodgeSkill,
		parrySkill
	)
	{
		this.constitution = constitution;
		this.strength = strength;
		this.dexterity = dexterity;
		this.wisdom = wisdom;
		this.size = size;

		this.lifeForce = lifeForce;
		this.power = power;
		this.speed = speed;

		this.missileSkill = missileSkill;
		this.meleeSkill = meleeSkill;
		this.armorSkill = armorSkill;
		this.dodgeSkill = dodgeSkill;
		this.parrySkill = parrySkill;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var bitStream = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var constitution = bitStream.readIntegerFromBits(6);
		var magicDamageResistance =
			bitStream.readIntegerFromBits(2);
		var strength = bitStream.readByte();
		var dexterity = bitStream.readByte();
		var lifeForce = bitStream.readByte();
		var speed = bitStream.readIntegerFromBits(4);
		var strategyAllegiance = bitStream.readIntegerFromBits(2);
		var strategyAggressionLevelId = bitStream.readBit();
		var strategyBraveryLevelId = bitStream.readBit();
		var power = bitStream.readByte();
		var dodgeSkill = bitStream.readByte();
		var parrySkill = bitStream.readByte();
		var armorSkill = bitStream.readByte(); // 0x19408
		var meleeSkill = bitStream.readIntegerFromBits(7);
		var mimicsOpponent = bitStream.readIntegerFromBits(1);
		var missileSkill = bitStream.readByte(); // 0x1940A
		var unknown2 = bitStream.readBytes(4); // B - E
		var size = bitStream.readByte(); // 0x1940F
		var unknown3 = bitStream.readByte();
		var wisdom = bitStream.readByte(); // 0x19411
		var wealthAsBytes = bitStream.readBytes(2);
		var wealth = converter.bytesToIntegerUnsignedBE(wealthAsBytes); // 0x19412-13
		var itemReadiedIdWeapon = bitStream.readByte(); // 0x19414
		var itemReadiedIdArmor = bitStream.readByte(); // 0x19415
		var pictureId = bitStream.readByte();

		var attributes = new CreatureAttributes
		(
			constitution,
			strength,
			dexterity,
			wisdom,
			size,
			lifeForce,
			power,
			speed,
			missileSkill,
			meleeSkill,
			armorSkill,
			dodgeSkill,
			parrySkill
		);

		return attributes;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class CreatureEquipment
{
	constructor
	(
		wealth,
		itemsHeld,
		itemReadiedArmor,
		itemReadiedWeapon
	)
	{
		this.wealth = wealth;
		this.itemsHeld = itemsHeld;
		this.itemReadiedArmor = itemReadiedArmor;
		this.itemReadiedWeapon = itemReadiedWeapon;
	}
}

class CreatureStrategy
{
	constructor
	(
		id, braveryLevelId, agressionLevelId, allegianceId
	)
	{
		this.id = id;
		this.braveryLevelId = braveryLevelId;
		this.agressionLevelId = aggressionLevelId;
		this.allegianceId = allegianceId;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}
}

class CreatureStrategyAggressionLevel
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyAggressionLevel_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyAggressionLevel_Instances
{
	constructor()
	{
		var csal = (id, n) => new CreatureStrategyAggressionLevel(id, n);

		this.Agressive = csal(1, "Aggressive");
		this.Peaceful = csal(2, "Peaceful");

		this._All =
		[
			this.Aggressive,
			this.Peaceful
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureStrategyAllegiance
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyAllegiance_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyAllegiance_Instances
{
	constructor()
	{
		var csa = (id, n) => new CreatureStrategyAllegiance(id, n);

		this.Enemy = csa("Aggressive");
		this.Friend = csa("Peaceful");
		this.Neutral = csa("Neutral");
		this.Thief = csa("Thief");

		this._All =
		[
			this.Enemy,
			this.Friend,
			this.Neutral,
			this.Thief
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureStrategyBraveryLevel
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyBraveryLevel_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyBraveryLevel_Instances
{
	constructor()
	{
		var csbl = (id, n) => new CreatureStrategyBraveryLevel(id, n);

		this.Brave = csbl(1, "Brave");
		this.Cautious = csbl(2, "Cautious");

		this._All =
		[
			this.Brave,
			this.Cautious
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new CreatureType_Instances();
		}

		return this._instances;
	}
}

class CreatureType_Instances
{
	constructor()
	{
		var ct = (id, name) => new CreatureType(id, name);
		this.PersonsFriends = ct(1, "Persons-Friends");
		this.PersonsEnemies = ct(2, "Persons-Enemies");
		this.PersonsNeutral = ct(3, "Persons-Neutral");
		this.PersonsThieves = ct(4, "Persons-Thieves");
		this.BeastsHostile 	= ct(5, "Beasts-Hostile");
		this.BeastsNeutral 	= ct(6, "Beasts-Neutral");
		this.EvilBeings 	= ct(7, "Evil Beings");
		this.YourNewIdea 	= ct(8, "Your New Idea");

		this._All =
		[
			this.PersonsFriends,
			this.PersonsEnemies,
			this.PersonsNeutral,
			this.PersonsThieves,
			this.BeastsHostile,
			this.BeastsNeutral,
			this.EvilBeings,
			this.YourNewIdea,
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class Effect
{
	constructor(effectTypeId, effectParameter)
	{
		this.effectTypeId = effectTypeId;
		this.effectParameter = effectParameter;
	}

	apply()
	{
		var effectType = this.effectType();
	}

	effectType()
	{
		return EffectType.byId(this.effectTypeId);
	}
}

class EffectType
{
	constructor(name, text, apply)
	{
		this.name = name;
		this.text = text;
		this._apply = apply;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new EffectType_Instances();
		}
		return this._instances;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	apply()
	{
		this._apply();
	}
}

class EffectType_Instances
{
	constructor()
	{
		var et = (n, a) => new EffectType(n, a || this.apply_DoNothing);

		this.DoNothing 				= et("Do Nothing", this.apply_DoNothing);

		this.ActivateEverything		= et("Activate Everything");
		this.AttributeDecrease		= et("Decrease Attribute");
		this.AttributeIncrease		= et("Increase Attribute");
		this.CreatureSummonOrBanish = et("Summon or Banish Creature");
		this.ItemAddToRoom			= et("Add Item to Room");
		this.ItemGive 				= et("Give Item");
		this.ItemsUncarriedRemove	= et("Remove Uncarried Items");
		this.KillIfItemNotHeld 		= et("Kill Anyone Who Lacks");
		this.LifeForceChange		= et("Change Life Force");
		this.MagicDefenseDecrease	= et("Decrease Magic Defense");
		this.MagicDefenseIncrease	= et("Increase Magic Defense");
		this.MessageLongDisplay 	= et("Display Long Message");
		this.MusicPlay				= et("Play Music");
		this.PowerChange			= et("Change Power");

		this._All =
		[
			this.DoNothing,

			this.ActivateEverything,
			this.AttributeDecrease,
			this.AttributeIncrease,
			this.CreatureSummonOrBanish,
			this.ItemAdd,
			this.ItemsUncarriedRemove,
			this.KillIfItemNotHeld,
			this.LifeForceChange,
			this.MagicDefenseDecrease,
			this.MagicDefenseIncrease,
			this.MessageLongDisplay,
			this.MusicPlay,
			this.PowerChange,
		];
	}

	apply_DoNothing()
	{
		// Do nothing.
	}

	apply_ActivateEverything() {}
	apply_AttributeDecrease() {}
	apply_AttributeIncrease() {}
	apply_CreatureSummonOrBanish() {}
	apply_ItemAdd() {}
	apply_ItemsUncarriedRemove() {}
	apply_KillIfItemNotHeld() {}
	apply_LifeForceChange() {}
	apply_MagicDefenseDecrease() {}
	apply_MagicDefenseIncrease() {}
	apply_MessageLongDisplay() {}
	apply_MusicPlay() {}
	apply_PowerChange() {}

}

class Message
{
	constructor(id, text)
	{
		this.id = id;
		this.text = text;
	}
}

class MusicalTheme
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	Instances()
	{
		if (this._instances == null)
		{
			this._instances = new MusicalTheme_Instances();
		}
		return this._instances;
	}
}

class MusicalTheme_Instances
{
	constructor()
	{
		this.Fantasy = new MusicalTheme("Fantasy");
		this.SciFi = new MusicalTheme("SciFi");
		this.Spy = new MusicalTheme("Spy");

		this._All =
		[
			this.Fantasy,
			this.SciFi,
			this.Spy
		];
	}
}

class Picture
{
	constructor(id, pixelColorIndexRows)
	{
		this.id = id;
		this.pixelColorIndexRows =
			pixelColorIndexRows;
		if (this.pixelColorIndexRows == null)
		{
			var size = Picture.sizeInPixels();
			this.pixelColorIndexRows = [];
			for (var y = 0; y < size.y; y++)
			{
				var pixelColorIndexRow = [];
				for (var x = 0; x < size.x; x++)
				{
					pixelColorIndexRow.push(0);
				}
				this.pixelColorIndexRows.push(pixelColorIndexRow);
			}
		}
	}

	static fromId(id)
	{
		return new Picture(id, null);
	}

	static sizeInPixels()
	{
		if (this._sizeInPixels == null)
		{
			this._sizeInPixels = Coords.fromXY(16, 16);
		}
		return this._sizeInPixels;
	}

	pixelAtPosGetColorIndex(pixelPos)
	{
		return this.pixelColorIndexRows[pixelPos.y][pixelPos.x];
	}

	pixelAtPosSetToColorIndex(pixelPos, colorIndex)
	{
		var row = this.pixelColorIndexRows[pixelPos.y];
		row[pixelPos.x] = colorIndex;
	}

	toCanvas()
	{
		if (this._canvas == null)
		{
			var colorsByIndex = // hack - Palette colors might be modified.
			[
				"Black",
				"Blue",
				"Brown",
				"White"
			];
		
			var d = document;
			var canvas = d.createElement("canvas");
			var pictureSizeInPixels = Picture.sizeInPixels();
			canvas.width = pictureSizeInPixels.x;
			canvas.height = pictureSizeInPixels.y;
			var g = canvas.getContext("2d");

			var pixelPosInPixels = new Coords();
			for (var py = 0; py < pictureSizeInPixels.y; py++)
			{
				pixelPosInPixels.y = py;
				for (var px = 0; px < pictureSizeInPixels.x; px++)
				{
					pixelPosInPixels.x = px;
					var pixelColorIndex =
						this.pixelAtPosGetColorIndex(pixelPosInPixels);
					var pixelColor =
						colorsByIndex[pixelColorIndex];
					g.fillStyle = pixelColor;
					g.fillRect(pixelPosInPixels.x, pixelPosInPixels.y, 1, 1);
				}
			}

			this._canvas = canvas;
		}

		return this._canvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var id = "todo";
		var bitStream = BitStream.fromBytes(bytes);
		var pixelColorIndexRows = [];
		var pictureDimensionInPixels = 16;
		var pixelColorIndexRows = [];
		for (var y = 0; y < pictureDimensionInPixels; y++)
		{
			var pixelColorIndicesForRow = [];

			for (var x = 0; x < pictureDimensionInPixels; x++)
			{
				var pixelColorIndex = bitStream.readIntegerFromBits(2);
				pixelColorIndicesForRow.push(pixelColorIndex);
			}

			pixelColorIndexRows.push(pixelColorIndicesForRow);
		}

		var picture = new Picture(id, pixelColorIndexRows);

		return picture;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// JSON.

	static manyToJson(pictures)
	{
		var picturesAsJson =
			pictures.map(x => x.toJson() );
		var picturesAsJsonJoined =
			"{\n"
			+ picturesAsJson.join(",\n");
			+ "\n}";
		return picturesAsJsonJoined;
	}

	toJson()
	{
		var pixelColorIndexRowsAsStrings =
			this.pixelColorIndexRows.map(x => x.join("") );

		var objectToStringify =
		{
			_typeName: Picture.name,
			id: this.id,
			pixelColorIndexRows: pixelColorIndexRowsAsStrings
		};
		return JSON.stringify(objectToStringify, null, 4);
	}
}

class Region
{
	constructor(id, name, rooms)
	{
		this.id = id;
		this.name = name;
		this.rooms = rooms || [];
	}

	static fromIdAndName(id, name)
	{
		return new Region(id, name, null);
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var regionId = -1; // todo
		var regionName =
			converter.bytesToString(reader.readBytes(20) );

		var rooms = [];

		var region = new Region(regionId, regionName, rooms);

		return region;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Room
{
	constructor(id, name, roomMap)
	{
		this.id = id;
		this.name = name;
		this.roomMap = roomMap;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMap
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMapCell
{
	constructor()
	{
		// todo
	}
}

class Thing
{
	constructor
	(
		id,
		name,
		typeId,
		pictureId,
		countGeneratedMax,
		properties
	)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.pictureId = pictureId;
		this.countGeneratedMax = countGeneratedMax;
		this.properties = properties;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromIdNameAndBytes(id, name, bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var typeId = "todo";

		//reader.byteIndexSetByteIndex(0x1C000);
		var countGeneratedMax =
			reader.readIntegerFromBits(4);

		//reader.byteIndexSetByteIndex(0x1C087);
		var power = reader.readIntegerFromBits(5);
		var range = reader.readIntegerFromBits(5);
		var attackAdjustmentEncoded =
			reader.readIntegerFromBits(4);
		var attackAdjustmentAsPercentage = 
			attackAdjustmentEncoded * 5 - 40;
		var chanceOfBreakingAsPercentage =
			reader.readIntegerFromBits(4);
		var isMagic = (reader.readBit() > 0);
		var onlyOwnerCanUse = (reader.readBit() > 0);
		var pictureId = reader.readIntegerFromBits(6);

		//reader.byteIndexSet(0x1BD00);
		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		var properties = []; // todo

		return new Thing
		(
			id,
			name,
			typeId,
			pictureId,
			countGeneratedMax,
			properties
		);
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class ThingPropertiesArmor
{
	constructor
	(
		power,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage
	)
	{
		this.power = power;
		this.attackAdjustmentAsPercentage =
			attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage =
			chanceOfBreakingAsPercentage;
	}
}

class ThingPropertiesCarryable
{
	constructor
	(
		weight,
		value,
		magical,
		disappearsWhenDropped,
		disappearsWhenUsed
	)
	{
		this.weight = weight;
		this.value = value;
		this.magical = magical;
		this.disappearsWhenDropped = disappearsWhenDropped;
		this.disappearsWhenUsed = disappearsWhenUsed;
		this.disappearsWhenHolderDies = disappearsWhenHolderDies;
	}
}

class ThingPropertiesEffector
{
	// "Magic Spell".
	constructor()
	{
		this.powerToTrigger = powerToTrigger;
		this.effectWhenTriggered = effectWhenTriggered;
	}
}

class ThingPropertiesObstacle
{
	constructor(effectWhenBumped)
	{
		this.effectWhenBumped = effectWhenBumped;
	}
}

class ThingPropertiesSpace
{
	constructor
	(
		itemNeededToPassId,
		itemNeededToPassIsDestroyed,
		itemForbiddenToPassId,
		textToShowWhenBlocked,
		effectWhenSteppedOn
	)
	{
		this.itemNeededToPassId = itemNeededToPassId;
		this.itemNeededToPassIsDestroyed =
			itemNeededToPassIsDestroyed;
		this.itemForbiddenToPassId = itemForbiddenToPassId;
		this.textToShowWhenBlocked = textToShowWhenBlocked;
		this.effectWhenSteppedOn = effectWhenSteppedOn;
	}
}

class ThingPropertiesSpaceCustom
{
	constructor()
	{
		// todo
	}
}

class ThingPropertiesStore
{
	constructor()
	{}
}

class ThingPropertiesDevice
{
	// "Magic Item".

	constructor
	(
		triggersWhenPickedUp,
		triggersWhenUsed,
		triggersWhenDropped,
		effectWhenTriggered
	)
	{
		this.effectWhenUsed = effectWhenUsed;
	}
}

class ThingPropertiesUsable
{
	constructor(durable)
	{
		this.durable = durable;
	}
}

class ThingPropertiesWeapon
{
	constructor
	(
		power,
		range,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage
	)
	{
		this.power = power;
		this.range = range;
		this.attackAdjustmentAsPercentage =
			attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage =
			chanceOfBreakingAsPercentage;
	}
}

class ThingType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new ThingType_Instances();
		}

		return this._instances;
	}
}

class ThingType_Instances
{
	constructor()
	{
		this.Armor			= new ThingType(1, "Armor");
		this.MagicItems		= new ThingType(2, "Magic Items");
		this.MeleeWeapons	= new ThingType(3, "Melee Weapons");
		this.MissileWeapons = new ThingType(4, "Missile Weapons");
		this.MagicSpells	= new ThingType(5, "Magic Spells");
		this.Treasure		= new ThingType(6, "Treasure");

		this._All =
		[
			this.Armor,
			this.MagicItems,
			this.MeleeWeapons,
			this.MissileWeapons,
			this.MagicSpells,
			this.Treasure
		];
	}
}

class WorldMap
{
	constructor
	(
		name,
		wrappingIsAllowed,
		entryPoint,
		terrainDefinitions,
		creatureOccurrences,
		sizeInCells,
		cellsAsTerrainIndexRows
	)
	{
		this.name = name;
		this.wrappingIsAllowed = wrappingIsAllowed;
		this.entryPoint = entryPoint;
		this.terrainDefinitions = terrainDefinitions;
		this.creatureOccurrences = creatureOccurrences;
		this.sizeInCells = sizeInCells;
		this.cellsAsTerrainIndexRows = cellsAsTerrainIndexRows;
	}

	terrainAtPosInCells(posInCells)
	{
		var terrainIndex =
			this.terrainIndexAtPosInCells(posInCells);
		var terrain = this.terrainDefinitions[terrainIndex];
		return terrain;
	}

	terrainIndexAtPosInCells(posInCells)
	{
		var cellTerrainIndexRow =
			this.cellsAsTerrainIndexRows[posInCells.y];
		var cellTerrainIndex =
			cellTerrainIndexRow[posInCells.x];
		return cellTerrainIndex;
	}

	toCanvas(adventure)
	{
		var d = document;

		var mapSizeInCells = this.sizeInCells;
		var pictureSizeInPixels = Picture.sizeInPixels();
		var cellSizeInPixels = pictureSizeInPixels;
		var mapSizeInPixels =
			mapSizeInCells
				.clone()
				.multiply(cellSizeInPixels);

		var mapAsCanvas = d.createElement("canvas");
		mapAsCanvas.width = mapSizeInPixels.x;
		mapAsCanvas.height = mapSizeInPixels.y;
		var graphics = mapAsCanvas.getContext("2d");

		var cellPosInCells = new Coords(0, 0);
		var drawPosInPixels = new Coords(0, 0);
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < mapSizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellTerrain =
					this.terrainAtPosInCells(cellPosInCells);

				drawPosInPixels
					.overwriteWith(cellPosInCells)
					.multiply(cellSizeInPixels);

				var cellTerrainPicture =
					cellTerrain.picture(adventure);
				var cellTerrainPictureAsCanvas =
					cellTerrainPicture.toCanvas();

				graphics.drawImage
				(
					cellTerrainPictureAsCanvas,
					drawPosInPixels.x, drawPosInPixels.y
				);
			}
		}

		return mapAsCanvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		// Start with 0x1C000.

		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		reader.byteIndexSet(0x42C);
		var wrappingIsAllowed =
			reader.readByte() > 0;

		var name =
			converter.bytesToString(reader.readBytes(20) );

		reader.byteIndexSet(0x700 + 234); // hack
		var mapSizeInCells = new Coords(40, 40);
		var bitsPerCell = 4; // 16 terrains.
		var mapCellsCount =
			mapSizeInCells.x
			* mapSizeInCells.y;
		var bitsPerByte = 8;
		var mapCellsSizeInBytes =
			mapCellsCount * bitsPerCell / bitsPerByte;
		var mapCellPairsAsBytes =
			reader.readBytes(mapCellsSizeInBytes);
		var terrainIndicesForCells = [];
		for (var i = 0; i < mapCellPairsAsBytes.length; i++)
		{
			var cellPairAsByte = mapCellPairsAsBytes[i];
			var cellLeftTerrainIndex =
				cellPairAsByte >> 4;
			var cellRightTerrainIndex =
				cellPairAsByte & 0x0F;
			terrainIndicesForCells.push(cellLeftTerrainIndex);
			terrainIndicesForCells.push(cellRightTerrainIndex);
		}

		var cellsAsTerrainIndexRows = [];
		var cellsPerRow = mapSizeInCells.x;
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			var cellIndexStart = y * cellsPerRow;
			var cellIndexEnd =
				cellIndexStart + cellsPerRow;

			var terrainIndexRow =
				terrainIndicesForCells
					.slice(cellIndexStart, cellIndexEnd);
			cellsAsTerrainIndexRows
				.push(terrainIndexRow);
		}

		reader.byteIndexSet(0x7a0);
		var playerEntryPoint = new Coords
		(
			reader.readByte(), reader.readByte()
		);

		var td = (id, name) => new WorldMapTerrain(id, name, id, null);
		var terrainDefinitions =
		[
			td(0,	"Water"),
			td(1,	"Plain"),
			td(2,	"Swamp"),
			td(3,	"Desert"),
			td(4,	"Dense Forest"),
			td(5,	"Forest"),
			td(6,	"Chapparal"),
			td(7,	"Fields"),
			td(8,	"Mountains"),
			td(9,	"Foothills"),
			td(10,	"River"),
			td(11,	"High Mountains"),
			td(12,	"Gateway"),
			td(13,	"Parapet Gateway"),
			td(14,	"Castle"),
			td(15,	"Old Church")
		];

		var creatureOccurrences = []; // todo
		/*
		reader.byteIndexSet(0xb0a);
		var creatureOccurrenceSizeInBytes = 592; // ?
		var creatureOccurrencesCount = 8;
		for (var i = 0; i < creatureOccurrencesCount; i++)
		{
			var creatureOccurrenceAsBytes =
				reader.readBytes(creatureOccurrenceSizeInBytes);
		}
		*/

		var worldMap = new WorldMap
		(
			name,
			wrappingIsAllowed,
			playerEntryPoint,
			terrainDefinitions,
			creatureOccurrences,
			mapSizeInCells,
			cellsAsTerrainIndexRows
		);

		return worldMap;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class WorldMapCreatureOccurrence
{}

class WorldMapTerrain
{
	constructor(id, name, pictureIndex, passability)
	{
		this.id = id;
		this.name = name;
		this.pictureIndex = pictureIndex;
		this.passability = passability;
	}

	picture(adventure)
	{
		return adventure.pictureByIndex(this.pictureIndex);
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}

}

class WorldMapTerrainPassability
{
	constructor()
	{
		// todo
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}



</script>