<html>
<body>

<div id="divUi">

	<h3>_Adventure Construction Set_ Save Editor</h3>

	<p>
		Upload an ADVEN.HRD file from the classic DOS-era game
		_Adventure Construction Set_ to see a text representation
		of its contents.  Some samples are provided
		<a href="../Demo/index.html">here</a>.
	</p>

	<div>
		<label>Adventure File:</label>
		<input
			id="inputFile"
			type="file"
			onchange="UiEventHandler.inputFile_Changed(this)"
		></input>
	</div>

	<div>
		<button
			onclick="UiEventHandler.buttonSelect_Clicked()"
		>
			Select:
		</button>
		<select
			id="selectObjectToDrawType"
		>
			<option>-</option>
			<option>Creature</option>
			<option>Creature Types</option>
			<option>Picture</option>
			<option>Region</option>
			<option>Room</option>
			<option>Thing</option>
			<option>Thing Types</option>
			<option>World Map</option>
		</select>
		<label>with ID:</label>
		<input
			id="inputObjectToDrawId"
			type="number"
			min="0" max="128"
			value="1"
		></input>
		<div id="divObjectToDraw">
			[nothing to draw yet]
		</div>
	</div>

	<div>
		<label>Object Selected as JSON:</label>
		<br />
		<textarea
			id="textareaJson"
			cols="80" rows="25"
			spellcheck="false"
		></textarea>
	</div>
	<div>
		<button onclick="UiEventHandler.buttonSave_Clicked()">
			Save to File
		</button>
	</div>
</div>

<script type="text/javascript" src="BitHandling/Source/BitStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteStream.js"></script>
<script type="text/javascript" src="BitHandling/Source/ByteConverter.js"></script>

<script type="text/javascript" src="BitHandling/Source/_Imports.js"></script>

<script type="text/javascript" src="TextDecoder.js"></script>

<script type="text/javascript">

class UiEventHandler
{
	static _adventureLoaded;
	static adventureLoaded()
	{
		return this._adventureLoaded;
	}

	static adventureLoadedSet(value)
	{
		this._adventureLoaded = value;
	}

	static buttonSave_Clicked()
	{
		alert("Not yet implemented!");
	}

	static buttonSelect_Clicked()
	{
		var d = document;

		var divObjectToDraw =
			d.getElementById("divObjectToDraw");
		divObjectToDraw.innerHTML = "";
		var textareaJson =
			d.getElementById("textareaJson");
		textareaJson.value = "[none]";

		var adventure = this.adventureLoaded();
		if (adventure == null)
		{
			divObjectToDraw.innerHTML =
				"[nothing to draw yet]";
		}
		else
		{
			var selectObjectToDrawType =
				d.getElementById("selectObjectToDrawType");
			var inputObjectToDrawId =
				d.getElementById("inputObjectToDrawId");

			var objectToDrawTypeName =
				selectObjectToDrawType.value;
			var objectToDrawId =
				parseInt(inputObjectToDrawId.value);

			if (objectToDrawTypeName == Creature.name)
			{
				if (objectToDrawId == 0)
				{
					var creatures = adventure.creatures;
					var creaturesAsCanvases =
						creatures.map(x => x.toCanvas(adventure) );
					divObjectToDraw.appendChild(...creaturesAsCanvases);
					var creaturesAsJson =
						Creature.manyToJson(creatures);
					textareaJson.value = creaturesAsJson;
				}
				else
				{
					var creature =
						adventure.creatureById(objectToDrawId);
					var creatureAsCanvas =
						creature.toCanvas(adventure);
					divObjectToDraw.appendChild(creatureAsCanvas);
					var creatureAsJson = creature.toJson(adventure);
					textareaJson.value = creatureAsJson;
				}
			}
			else if (objectToDrawTypeName == "Creature Types")
			{
				var creatureTypes = adventure.creatureTypes;
				var creatureTypesAsJson =
					JSON.stringify(creatureTypes, null, 4);
				textareaJson.value = creatureTypesAsJson;
			}
			else if (objectToDrawTypeName == Picture.name)
			{
				var pictures = adventure.pictures;

				if (objectToDrawId == 0)
				{
					for (var p = 0; p < pictures.length; p++)
					{
						var picture = pictures[p];
						var pictureAsCanvas = picture.toCanvas();
						divObjectToDraw.appendChild(pictureAsCanvas);
					}
					var picturesAsJson = Picture.manyToJson(pictures);
					textareaJson.value = picturesAsJson;
				}
				else
				{
					var picture = pictures[objectToDrawId - 1];
					var pictureAsCanvas = picture.toCanvas();
					divObjectToDraw.appendChild(pictureAsCanvas);
					var pictureAsJson = picture.toJson();
					textareaJson.value = pictureAsJson;
				}
			}
			else if (objectToDrawTypeName == Region.name)
			{
				var region = adventure.regionsById(objectToDrawId);
				var regionAsCanvas = region.toCanvas();
				divObjectToDraw.appendChild(regionAsCanvas);
				var regionAsJson = region.toJson();
				textareaJson.value = regionAsJson;
			}
			else if (objectToDrawTypeName == Room.name)
			{
				alert("todo");
			}
			else if (objectToDrawTypeName == Thing.name)
			{
				if (objectToDrawId == 0)
				{
					var things = adventure.things;
					var thingsAsCanvases =
						things.map(x => x.toCanvas(adventure) );
					divObjectToDraw.appendChild(...thingsAsCanvases);
					var thingsAsJson =
						Thing.manyToJson(things);
					textareaJson.value = thingsAsJson;
				}
				else
				{
					var thing =
						adventure.thingById(objectToDrawId);
					var thingAsCanvas =
						thing.toCanvas(adventure);
					divObjectToDraw.appendChild(thingAsCanvas);
					var thingAsJson = thing.toJson();
					textareaJson.value = thingAsJson;
				}
			}
			else if (objectToDrawTypeName == "Thing Types")
			{
				var thingTypes = ThingType.Instances()._All;
				var thingTypesAsJson = JSON.stringify(thingTypes, null, 4);
				textareaJson.value = thingTypesAsJson;
			}
			else if (objectToDrawTypeName == "World Map")
			{
				var worldMap = adventure.worldMap;
				var worldMapAsCanvas =
					worldMap.toCanvas(adventure);
				divObjectToDraw.appendChild(worldMapAsCanvas);
			}
			else
			{
				alert("Choose a valid type.");
			}
		}
	}

	static inputFile_Changed(inputFile)
	{
		var file = inputFile.files[0];
		if (file != null)
		{
			var fileReader = new FileReader();
			fileReader.onload = (event) =>
			{
				var adventureAsBinaryString =
					event.target.result;
				var adventureAsBytes =
					adventureAsBinaryString.split("").map(x => x.charCodeAt(0) );
				var adventure =
					Adventure.fromBytes(adventureAsBytes);

				UiEventHandler.adventureLoadedSet(adventure);

				var adventureAsJson = adventure.toJson();

				var d = document;
				var textareaJson =
					d.getElementById("textareaJson");
				textareaJson.value = adventureAsJson;
			};
			fileReader.readAsBinaryString(file);
		}
	}
}

// Classes.

class Adventure
{
	constructor
	(
		name,
		authorName,
		musicalThemeId,
		pictures,
		worldMap,
		regions,
		things,
		creatureTypes,
		creatures,
		messages
	)
	{
		this.name = name;
		this.authorName = authorName;
		this.musicalThemeId = musicalThemeId;
		this.pictures = pictures;
		this.worldMap = worldMap;
		this.regions = regions;
		this.things = things;
		this.creatureTypes = creatureTypes;
		this.creatures = creatures;
		this.messages = messages;
	}

	creatureById(creatureId)
	{
		var creatureIndex = creatureId - 1;
		return this.creatures[creatureIndex];
	}

	creatureTypeById(creatureTypeId)
	{
		var creatureTypeIndex = creatureTypeId; // - 1?
		return this.creatureTypes[creatureTypeIndex];
	}

	pictureById(pictureId)
	{
		return this.pictures[pictureId];
	}

	regionById(regionId)
	{
		var regionIndex = regionId - 1;
		return this.regions[regionIndex];
	}

	thingById(thingId)
	{
		var thingIndex = thingId - 1;
		return this.things[thingIndex];
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var textDecoder = TextDecoder.Instance();
		var converter = new ByteConverter();

		var reader = BitStream.fromBytes(bytes);

		var messages =
			Message.manyFromBytes(reader, converter);

		var things =
			Thing.manyFromBytes(reader, converter, textDecoder);

		var creatureTypes =
			CreatureType.manyFromBytes(reader, converter, TextDecoder);

		var creatures =
			Creature.manyFromBytes(reader, converter, textDecoder);

		var adventureNameOffsetInBytes = 0x1C200;
		reader.byteIndexSet(adventureNameOffsetInBytes);
		var adventureName = converter.bytesToString(reader.readBytes(14) );
		var authorName = converter.bytesToString(reader.readBytes(14) );

		//reader.byteIndexSet(0x1C229);
		var regionCount = reader.readByte();
		var regions = [];
		var regionNamesOffsetInBytes = 0x1C441;
		var regionNameSizeInBytes = 20;
		reader.byteIndexSet(regionNamesOffsetInBytes);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var regionNameAsBytes =
				reader.readBytes(regionNameSizeInBytes);
			var regionName =
				converter.bytesToString(regionNameAsBytes);
			var region = Region.fromIdAndName(rg, regionName);
			regions.push(region);
		}

		//reader.byteIndexSet(todo);
		for (var rg = 0; rg < regionCount; rg++)
		{
			var region = regions[rg];
			var regionRooms = [];
			var roomCount = 10;
			// todo
		}

		var worldMapOffsetInBytes = 0x1C000; // hack
		reader.byteIndexSet(worldMapOffsetInBytes);
		var worldMapSizeInBytes = 0x1000; // todo
		var worldMapAsBytes = reader.readBytes(worldMapSizeInBytes);
		var worldMap = WorldMap.fromBytes(worldMapAsBytes);

		reader.byteIndexSet(0x1C56e);
		var musicalThemeId = reader.readByte();

		var pictures = Picture.manyFromBytes(reader);

		var adventure = new Adventure
		(
			adventureName,
			authorName,
			musicalThemeId,
			pictures,
			worldMap,
			regions,
			things,
			creatureTypes,
			creatures,
			messages
		);

		return adventure;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Json.

	fromJson()
	{
		throw new Error("todo");
	}

	toJson()
	{
		return "New adventure loaded.";
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static fromXY(x, y)
	{
		return new Coords(x, y);
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	multiplyScalar(scalar)
	{
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	toString()
	{
		return this.x + "x" + this.y;
	}
}

class Creature
{
	constructor
	(
		id,
		name,
		creatureTypeId,
		pictureId,
		attributes,
		strategy,
		mimicsOpponent,
		equipment
	)
	{
		this.id = id;
		this.name = name;
		this.creatureTypeId = creatureTypeId;
		this.pictureId = pictureId;
		this.attributes = attributes;
		this.strategy = strategy;
		this.mimicsOpponent = mimicsOpponent;
		this.equipment = equipment;
	}

	static fromIdNameTypeIdAndBytes(id, name, creatureTypeId, bytes)
	{
		var creature = Creature.fromBytes(bytes);
		creature.id = id;
		creature.name = name;
		creature.creatureTypeId = creatureTypeId;
		return creature;
	}

	creatureType(adventure)
	{
		return adventure.creatureTypeById(this.creatureTypeId);
	}

	// Bytes.

	static manyFromBytes(reader, converter, textDecoder)
	{
		var creaturesCount = 128; // ?

		var creatureTypesOffsetInBytes = 0x1B200;
		var creatureTypeIdLengthInBytes = 1; // Really only the last 3 bits of that, though?
		var creatureTypeIds = [];
		for (var c = 0; c < creaturesCount; c++)
		{
			var unknown = reader.readBits(5); // ?
			var creatureTypeId = reader.readIntegerFromBits(3);
			creatureTypeIds.push(creatureTypeId);
		}

		var creatureNamesOffsetInBytes = 0x1B280;
		reader.byteIndexSet(creatureNamesOffsetInBytes);

		var creatureNameSizeInBytes = 10;

		var creatureNames = [];
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureNameEncodedAsBytes =
				reader.readBytes(creatureNameSizeInBytes);
			var creatureName =
				textDecoder
					.bytesDecodeToString(creatureNameEncodedAsBytes)
					.trim();
			creatureNames.push(creatureName);
		}

		var creaturesDataOffsetInBytes = 0x19400;
		reader.byteIndexSet(creaturesDataOffsetInBytes);
		var creaturesSoFar = [];
		var creatureSizeInBytes = 37; // 0x25.
		for (var c = 0; c < creaturesCount; c++)
		{
			var creatureId = c + 1;
			var creatureName = creatureNames[c];
			var creatureTypeId = creatureTypeIds[c];
			var creatureAsBytes = reader.readBytes(creatureSizeInBytes);
			var creature = Creature.fromIdNameTypeIdAndBytes
			(
				creatureId, creatureName, creatureTypeId, creatureAsBytes
			);
			creaturesSoFar.push(creature);
		}

		return creaturesSoFar;
	}

	static fromBytes(bytes)
	{
		var reader = ByteStream.fromBytes(bytes);

		var id = -1; // todo
		var name = "todo";
		var typeId = -1; // todo
		var attributesAsBytes = reader.readBytes(37);

		var bitStream = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var magicDamageResistance =
			bitStream.readIntegerFromBits(2); // todo
		var constitution = bitStream.readIntegerFromBits(6);
		var strength = bitStream.readByte();
		var dexterity = bitStream.readByte();
		var lifeForce = bitStream.readByte();

		var strategyBraveryLevelId = bitStream.readBit();
		var strategyAggressionLevelId = bitStream.readBit();
		var strategyAllegianceId = bitStream.readIntegerFromBits(2);

		var strategy = new CreatureStrategy
		(
			strategyBraveryLevelId,
			strategyAggressionLevelId,
			strategyAllegianceId
		);

		var speed = bitStream.readIntegerFromBits(4);

		var power = bitStream.readByte();
		var dodgeSkill = bitStream.readByte();
		var parrySkill = bitStream.readByte();
		var armorSkill = bitStream.readByte(); // 0x19408
		var mimicsOpponent = bitStream.readIntegerFromBits(1) > 0;
		var meleeSkill = bitStream.readIntegerFromBits(7);
		var missileSkill = bitStream.readByte(); // 0x1940A
		var unknown2 = bitStream.readBytes(4); // B - E
		var size = bitStream.readByte(); // 0x1940F
		var unknown3 = bitStream.readByte();
		var wisdom = bitStream.readByte(); // 0x19411
		var wealthAsBytes = bitStream.readBytes(2);
		var wealth = converter.bytesToIntegerUnsignedBE(wealthAsBytes); // 0x19412-13
		var itemReadiedIdWeapon = bitStream.readByte(); // 0x19414
		var itemReadiedIdArmor = bitStream.readByte(); // 0x19415
		var pictureId = bitStream.readByte() - 2; // ?

		var attributes = new CreatureAttributes
		(
			constitution,
			strength,
			dexterity,
			wisdom,
			size,
			lifeForce,
			power,
			speed,
			missileSkill,
			meleeSkill,
			armorSkill,
			dodgeSkill,
			parrySkill
		);

		var itemsHeld = []; // todo

		var equipment = new CreatureEquipment
		(
			wealth,
			itemsHeld,
			itemReadiedIdArmor,
			itemReadiedIdWeapon
		);

		var creature = new Creature
		(
			id,
			name,
			typeId,
			pictureId,
			attributes,
			strategy,
			mimicsOpponent,
			equipment
		);

		return creature;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Drawing.

	picture(adventure)
	{
		return adventure.pictureById(this.pictureId);
	}

	toCanvas(adventure)
	{
		return this.picture(adventure).toCanvasEnlarged();
	}

	// JSON.

	static fromJson(creatureAsJson)
	{
		throw new Error("todo");
	}

	toJson(adventure)
	{
		var creatureTypeName = this.creatureType(adventure).name;
		var strategyAsString = this.strategy.toString();

		var thisAsObjectToSerialize =
		{
			id: this.id,
			name: this.name,
			type: creatureTypeName,
			pictureId: this.pictureId,
			attributes: this.attributes,
			strategy: strategyAsString,
			mimicsOpponent: this.mimicsOpponent,
			equipment: this.equipment
		};

		return JSON.stringify(thisAsObjectToSerialize, null, 4);
	}
}

class CreatureAttributes
{
	constructor
	(
		constitution,
		strength,
		dexterity,
		wisdom,
		size,

		lifeForce,
		power,
		speed, // action points?

		missileSkill,
		meleeSkill,
		armorSkill,
		dodgeSkill,
		parrySkill
	)
	{
		this.constitution = constitution;
		this.strength = strength;
		this.dexterity = dexterity;
		this.wisdom = wisdom;
		this.size = size;

		this.lifeForce = lifeForce;
		this.power = power;
		this.speed = speed;

		this.missileSkill = missileSkill;
		this.meleeSkill = meleeSkill;
		this.armorSkill = armorSkill;
		this.dodgeSkill = dodgeSkill;
		this.parrySkill = parrySkill;
	}
}

class CreatureEquipment
{
	constructor
	(
		wealth,
		itemsHeld,
		itemReadiedIdArmor,
		itemReadiedIdWeapon
	)
	{
		this.wealth = wealth;
		this.itemsHeld = itemsHeld;
		this.itemReadiedIdArmor = itemReadiedIdArmor;
		this.itemReadiedIdWeapon = itemReadiedIdWeapon;
	}
}

class CreatureStrategy
{
	constructor
	(
		braveryLevelId,
		aggressionLevelId,
		allegianceId
	)
	{
		this.braveryLevelId = braveryLevelId;
		this.aggressionLevelId = aggressionLevelId;
		this.allegianceId = allegianceId;
	}

	aggressionLevel()
	{
		return CreatureStrategyAggressionLevel.byId(this.aggressionLevelId);
	}

	allegiance()
	{
		return CreatureStrategyAllegiance.byId(this.allegianceId);
	}

	braveryLevel()
	{
		return CreatureStrategyBraveryLevel.byId(this.braveryLevelId);
	}

	toString()
	{
		var returnValue =
			this.braveryLevel().name
			+ " " + this.aggressionLevel().name
			+ " " + this.allegiance().name;
		return returnValue;
	}
}

class CreatureStrategyAggressionLevel
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyAggressionLevel_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyAggressionLevel_Instances
{
	constructor()
	{
		var csal = (id, n) => new CreatureStrategyAggressionLevel(id, n);

		this.Aggressive = csal(1, "Aggressive");
		this.Peaceful = csal(2, "Peaceful");

		this._All =
		[
			this.Aggressive,
			this.Peaceful
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureStrategyAllegiance
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyAllegiance_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyAllegiance_Instances
{
	constructor()
	{
		var csa = (id, n) => new CreatureStrategyAllegiance(id, n);

		this.Thief 		= csa(0, "Thief");
		this.Neutral 	= csa(1, "Neutral");
		this.Enemy 		= csa(2, "Enemy"); // ?
		this.Friend 	= csa(3, "Friend");

		this._All =
		[
			this.Thief,
			this.Neutral,
			this.Enemy,
			this.Friend
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureStrategyBraveryLevel
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances =
				new CreatureStrategyBraveryLevel_Instances();
		}
		return this._instances;
	}
}

class CreatureStrategyBraveryLevel_Instances
{
	constructor()
	{
		var csbl = (id, n) => new CreatureStrategyBraveryLevel(id, n);

		this.Brave = csbl(1, "Brave");
		this.Cautious = csbl(2, "Cautious");

		this._All =
		[
			this.Brave,
			this.Cautious
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}
}

class CreatureType
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	static manyFromBytes(reader, converter)
	{
		var creatureTypeNamesOffsetInBytes = 0x19300;
		reader.byteIndexSet(creatureTypeNamesOffsetInBytes);
		var creatureTypeNameSizeInBytes = 15;
		var creatureTypeNamesCount = 8
		var creatureTypes = [];
		for (var i = 0; i < creatureTypeNamesCount; i++)
		{
			var creatureTypeNameAsBytes =
				reader.readBytes(creatureTypeNameSizeInBytes);

			// This is weird.  A different encoding is used for default names.
			var creatureTypeNameIsDefault =
				creatureTypeNameAsBytes.some(x => x <= 0x20);
			if (creatureTypeNameIsDefault)
			{
				creatureTypeNameAsBytes =
					creatureTypeNameAsBytes.map(x => x >= 0x20 ? x : x + 0x40);
			}
			var creatureTypeName =
				converter
					.bytesToString(creatureTypeNameAsBytes)
					.trim();
			var creatureTypeId = i; // Add to it?
			var creatureType =
				new CreatureType(creatureTypeId, creatureTypeName);
			creatureTypes.push(creatureType);
		}

		return creatureTypes;
	}

}

class Effect
{
	constructor(effectTypeId, effectParameter)
	{
		this.effectTypeId = effectTypeId;
		this.effectParameter = effectParameter;
	}

	apply()
	{
		var effectType = this.effectType();
	}

	effectType()
	{
		return EffectType.byId(this.effectTypeId);
	}
}

class EffectType
{
	constructor(name, text, apply)
	{
		this.name = name;
		this.text = text;
		this._apply = apply;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new EffectType_Instances();
		}
		return this._instances;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	apply()
	{
		this._apply();
	}
}

class EffectType_Instances
{
	constructor()
	{
		var et = (n, a) => new EffectType(n, a || this.apply_DoNothing);

		this.DoNothing 				= et("Do Nothing", this.apply_DoNothing);

		this.ActivateEverything		= et("Activate Everything");
		this.AttributeDecrease		= et("Decrease Attribute");
		this.AttributeIncrease		= et("Increase Attribute");
		this.CreatureSummonOrBanish = et("Summon or Banish Creature");
		this.ItemAddToRoom			= et("Add Item to Room");
		this.ItemGive 				= et("Give Item");
		this.ItemsUncarriedRemove	= et("Remove Uncarried Items");
		this.KillIfItemNotHeld 		= et("Kill Anyone Who Lacks");
		this.LifeForceChange		= et("Change Life Force");
		this.MagicDefenseDecrease	= et("Decrease Magic Defense");
		this.MagicDefenseIncrease	= et("Increase Magic Defense");
		this.MessageLongDisplay 	= et("Display Long Message");
		this.MusicPlay				= et("Play Music");
		this.PowerChange			= et("Change Power");

		this._All =
		[
			this.DoNothing,

			this.ActivateEverything,
			this.AttributeDecrease,
			this.AttributeIncrease,
			this.CreatureSummonOrBanish,
			this.ItemAdd,
			this.ItemsUncarriedRemove,
			this.KillIfItemNotHeld,
			this.LifeForceChange,
			this.MagicDefenseDecrease,
			this.MagicDefenseIncrease,
			this.MessageLongDisplay,
			this.MusicPlay,
			this.PowerChange,
		];
	}

	apply_DoNothing()
	{
		// Do nothing.
	}

	apply_ActivateEverything() {}
	apply_AttributeDecrease() {}
	apply_AttributeIncrease() {}
	apply_CreatureSummonOrBanish() {}
	apply_ItemAdd() {}
	apply_ItemsUncarriedRemove() {}
	apply_KillIfItemNotHeld() {}
	apply_LifeForceChange() {}
	apply_MagicDefenseDecrease() {}
	apply_MagicDefenseIncrease() {}
	apply_MessageLongDisplay() {}
	apply_MusicPlay() {}
	apply_PowerChange() {}

}

class Message
{
	constructor(id, text)
	{
		this.id = id;
		this.text = text;
	}

	static manyFromBytes(reader, converter)
	{
		var messagesOffsetInBytes = 0x16C00;
		var messageSizeInBytes = 0x100;
		var messages = [];
		var messagesCount = 255; // todo
		reader.byteIndexSet(messagesOffsetInBytes);
		for (var m = 0; m < messagesCount; m++)
		{
			var messageAsBytes =
				reader.readBytes(messagesOffsetInBytes);
			var message = converter.bytesToString(messageAsBytes);
			messages.push(message);
		}

		return messages;
	}
}

class MusicalTheme
{
	constructor(id, name)
	{
		this.id = id;
		this.name = name;
	}

	Instances()
	{
		if (this._instances == null)
		{
			this._instances = new MusicalTheme_Instances();
		}
		return this._instances;
	}
}

class MusicalTheme_Instances
{
	constructor()
	{
		this.Fantasy = new MusicalTheme("Fantasy");
		this.SciFi = new MusicalTheme("SciFi");
		this.Spy = new MusicalTheme("Spy");

		this._All =
		[
			this.Fantasy,
			this.SciFi,
			this.Spy
		];
	}
}

class Picture
{
	constructor(id, pixelColorIndexRows)
	{
		this.id = id;
		this.pixelColorIndexRows =
			pixelColorIndexRows;
		if (this.pixelColorIndexRows == null)
		{
			var size = Picture.sizeInCells();
			this.pixelColorIndexRows = [];
			for (var y = 0; y < size.y; y++)
			{
				var pixelColorIndexRow = [];
				for (var x = 0; x < size.x; x++)
				{
					pixelColorIndexRow.push(0);
				}
				this.pixelColorIndexRows.push(pixelColorIndexRow);
			}
		}
	}

	static fromId(id)
	{
		return new Picture(id, null);
	}

	static sizeInCells()
	{
		if (this._sizeInCells == null)
		{
			this._sizeInCells = Coords.fromXY(16, 16);
		}
		return this._sizeInCells;
	}

	cellAtPosGetColorIndex(pixelPos)
	{
		return this.pixelColorIndexRows[pixelPos.y][pixelPos.x];
	}

	cellAtPosSetToColorIndex(pixelPos, colorIndex)
	{
		var row = this.pixelColorIndexRows[pixelPos.y];
		row[pixelPos.x] = colorIndex;
	}

	toCanvas()
	{
		return this.toCanvasWithScaleFactor(1);
	}

	toCanvasEnlarged()
	{
		return this.toCanvasWithScaleFactor(3);
	}

	toCanvasWithScaleFactor(scaleFactor)
	{
		if (this._canvas == null)
		{
			var colorsByIndex = // hack - Palette colors might be modified.
			[
				"Black",
				"Blue",
				"Brown",
				"White"
			];

			var d = document;
			var canvas = d.createElement("canvas");
			var pictureSizeInCells = Picture.sizeInCells();
			var cellSizeInPixels =
				new Coords(1, 1).multiplyScalar(scaleFactor);
			var pictureSizeInPixels =
				pictureSizeInCells
					.clone()
					.multiply(cellSizeInPixels);
			canvas.width = pictureSizeInPixels.x;
			canvas.height = pictureSizeInPixels.y;
			var g = canvas.getContext("2d");

			var cellPosInCells = new Coords();
			var cellPosInPixels = new Coords();

			for (var y = 0; y < pictureSizeInCells.y; y++)
			{
				cellPosInCells.y = y;

				for (var x = 0; x < pictureSizeInCells.x; x++)
				{
					cellPosInCells.x = x;

					var cellColorIndex =
						this.cellAtPosGetColorIndex(cellPosInCells);

					var cellColor =
						colorsByIndex[cellColorIndex];

					cellPosInPixels
						.overwriteWith(cellPosInCells)
						.multiply(cellSizeInPixels);

					g.fillStyle = cellColor;
					g.fillRect
					(
						cellPosInPixels.x, cellPosInPixels.y,
						cellSizeInPixels.x, cellSizeInPixels.y
					);
				}
			}

			this._canvas = canvas;
		}

		return this._canvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		var id = "todo";
		var bitStream = BitStream.fromBytes(bytes);
		var pixelColorIndexRows = [];
		var pictureDimensionInPixels = 16;
		var pixelColorIndexRows = [];
		for (var y = 0; y < pictureDimensionInPixels; y++)
		{
			var pixelColorIndicesForRow = [];

			for (var x = 0; x < pictureDimensionInPixels; x++)
			{
				var pixelColorIndex = bitStream.readIntegerFromBits(2);
				pixelColorIndicesForRow.splice(pixelColorIndex);
			}

			pixelColorIndexRows.push(pixelColorIndicesForRow);
		}

		var picture = new Picture(id, pixelColorIndexRows);

		return picture;
	}

	static manyFromBytes(reader)
	{
		var pictures = [];
		var picturesCount = 128; // ?
		for (var p = 0; p < picturesCount; p++)
		{
			var picture = Picture.fromId(p);
			pictures.push(picture);
		}

		var pictureSizeInPixels =
			Picture.sizeInCells(); // 16 x 16 pixels.
		var picturePixelCount =
			pictureSizeInPixels.x
			* pictureSizeInPixels.y;
		var bitsPerPixel = 2;
		var pictureSizeInBits =
			picturePixelCount * bitsPerPixel;
		var pictureSizeInBytes =
			pictureSizeInBits / 8;
		var pictureQuadrantSizeInBytes =
			pictureSizeInBytes / 4;

		var picture0OffsetInBytes = 0x28720; // ?
		reader.byteIndexSet(picture0OffsetInBytes);

		// 4x1 tetrads of pixels
		// are encoded as individual bytes.
		// The order of tetrads, in bytes offset from
		// the 0th tetrad, are:
		//	0...----8...----
		//	1...----9...----
		//	2...----a...----
		//	3...----b...----
		//	4...----c...----
		//	5...----d...----
		//	6...----e...----
		//	7...----f...----
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		//	----------------
		// The next byte encodes the upper-left
		// tetrad of pixels of the subsequent picture!
		// Assuming that it'll do those two columns of tetrads
		// in every picture next,
		// that's 16 bytes,
		// and there are 128 pictures(?),
		// so if we advance 16 x 128 = 2,048 bytes,
		// then we'll return to the next tetrad of pixels
		// in THIS picture.
		// Maybe it'll be the upper-left pixel
		// of the left half
		// of the lower-left quadrant?
		// That position is, uh, 28F30,
		// which is 2,048 bytes from the first,
		// upper-left byte of the picture.

		var octantPairOffsetWithinPictureInPixels = new Coords(0, 0);
		var octantOffsetWithinPairInPixels = new Coords(0, 0);
		var octantPosInPixels = new Coords(0, 0);
		var tetradOffsetWithinOctantInPixels = new Coords(0, 0);
		var pixelPosInPixels = new Coords(0, 0);
		var pixelsPerTetrad = 4;
		var octantsPerOctantPair = 2;
		var octantSizeInTetrads = 8;

		for (var octantPairIndex = 0; octantPairIndex < 4; octantPairIndex++)
		{
			if (octantPairIndex == 2)
			{
				// I don't know why this jump is needed,
				// or what lies in between.
				reader.byteIndexSet(0x2AB20);
			}

			octantPairOffsetWithinPictureInPixels.y =
				(octantPairIndex  % 2)
				* pictureSizeInPixels.y / 2;

			octantPairOffsetWithinPictureInPixels.x =
				Math.floor(octantPairIndex  / 2)
				* pictureSizeInPixels.x / 4;

			for (var p = 0; p < picturesCount; p++)
			{
				var picture = pictures[p];

				for (var octantIndexWithinPair = 0; octantIndexWithinPair < octantsPerOctantPair; octantIndexWithinPair++)
				{
					octantOffsetWithinPairInPixels.x =
						octantIndexWithinPair * pictureSizeInPixels.x / 2;

					octantPosInPixels.x =
						octantPairOffsetWithinPictureInPixels.x
						+ octantOffsetWithinPairInPixels.x;

					for (var ty = 0; ty < octantSizeInTetrads; ty++)
					{
						tetradOffsetWithinOctantInPixels.y = ty;

						pixelPosInPixels.y =
							octantPairOffsetWithinPictureInPixels.y
							+ octantOffsetWithinPairInPixels.y
							+ tetradOffsetWithinOctantInPixels.y;

						for (var i = 0; i < pixelsPerTetrad; i++)
						{
							pixelPosInPixels.x =
								octantPosInPixels.x
								+ i;

							var pixelColorIndex =
								reader.readIntegerFromBits(2);

							picture.cellAtPosSetToColorIndex
							(
								pixelPosInPixels,
								pixelColorIndex
							);
						}
					}
				}
			}
		}

		return pictures;
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// JSON.

	static manyToJson(pictures)
	{
		var picturesAsJson =
			pictures.map(x => x.toJson() );
		var picturesAsJsonJoined =
			"{\n"
			+ picturesAsJson.join(",\n");
			+ "\n}";
		return picturesAsJsonJoined;
	}

	toJson()
	{
		var pixelColorIndexRowsAsStrings =
			this.pixelColorIndexRows.map(x => x.join("") );

		var objectToStringify =
		{
			_typeName: Picture.name,
			id: this.id,
			pixelColorIndexRows: pixelColorIndexRowsAsStrings
		};
		return JSON.stringify(objectToStringify, null, 4);
	}
}

class Region
{
	constructor(id, name, rooms)
	{
		this.id = id;
		this.name = name;
		this.rooms = rooms || [];
	}

	static fromIdAndName(id, name)
	{
		return new Region(id, name, null);
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		var regionId = -1; // todo
		var regionName =
			converter.bytesToString(reader.readBytes(20) );

		var rooms = [];

		var region = new Region(regionId, regionName, rooms);

		return region;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class Room
{
	constructor(id, name, roomMap)
	{
		this.id = id;
		this.name = name;
		this.roomMap = roomMap;
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMap
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class RoomMapCell
{
	constructor()
	{
		// todo
	}
}

class Thing
{
	constructor
	(
		id,
		name,
		typeId,
		countGeneratedMax,
		details
	)
	{
		this.id = id;
		this.name = name;
		this.typeId = typeId;
		this.countGeneratedMax = countGeneratedMax;
		this.details = details;
	}

	picture()
	{
		return this.details.visible.picture(adventure);
	}

	thingType()
	{
		return ThingType.byId(this.typeId);
	}

	// Bytes.

	static manyFromBytes(reader, converter, textDecoder)
	{
		var thingNamesOffsetInBytes = 0x1B800;
		reader.byteIndexSet(thingNamesOffsetInBytes);

		var thingNameSizeInBytes = 10;
		var thingsCount = 128; // ?

		var thingNames = [];
		for (var t = 0; t < thingsCount; t++)
		{
			var thingNameEncodedAsBytes =
				reader.readBytes(thingNameSizeInBytes);
			var thingName =
				textDecoder
					.bytesDecodeToString(thingNameEncodedAsBytes)
					.trim();
			thingNames.push(thingName);
		}

		var thingTypeIds = [];
		for (var t = 0; t < thingsCount; t++)
		{
			var unknown = reader.readIntegerFromBits(4);
			var thingTypeId = reader.readIntegerFromBits(4);
			var unknown2 = reader.readBytes(3);
			thingTypeIds.push(thingTypeId);
		}
		// This leaves us at 0x1BF00,
		// which is 256 bytes unaccounted for.

		var thingsOffsetInBytes = 0x1C000; // ?
		reader.byteIndexSet(thingsOffsetInBytes);
		var things = [];
		var thingSizeInBytes = 4096; // ?
		for (var t = 0; t < thingsCount; t++)
		{
			var thingId = t + 1;
			var thingName = thingNames[t];
			var thingTypeId = thingTypeIds[t];
			var thingType = ThingType.byId(thingTypeId);
			if (thingType == null)
			{
				things.push(null);
			}
			else
			{
				var thingAsBytes = reader.readBytes(thingSizeInBytes);
				var thing = Thing.fromIdNameTypeAndBytes
				(
					thingId, thingName, thingType, thingAsBytes
				);
				things.push(thing);
			}
		}

		return things;
	}

	static fromIdNameTypeAndBytes(id, name, thingType, bytes)
	{
		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		//reader.byteIndexSetByteIndex(0x1C000);
		var countGeneratedMax =
			reader.readIntegerFromBits(4);

		reader.byteIndexSet(0x87); // hack

		var details =
			thingType.detailsFromBytes(reader);

		return new Thing
		(
			id,
			name,
			thingType.id,
			countGeneratedMax,
			details
		);
	}

	toBytes()
	{
		throw new Error("todo");
	}

	// Drawing.

	picture(adventure)
	{
		return adventure.pictureById(this.details.visible.pictureId);
	}

	toCanvas(adventure)
	{
		return this.picture(adventure).toCanvasEnlarged();
	}

	// Json.

	toJson()
	{
		var thisAsObjectToSerialize = this; // todo
		var thisSerialized =
			JSON.stringify(thisAsObjectToSerialize, null, 4);
		return thisSerialized;
	}
}

class ThingDetailsArmor
{
	constructor(visible, carryable, weapon)
	{
		this.visible = visible;
		this.carryable = carryable;
		this.weapon = weapon;
	}

	static fromBytes(reader)
	{
		var armorDetails =
			ThingDetailsArmorDetails.fromBytes(reader);

		var magical = (reader.readBit() > 0);
		var onlyOwnerCanUse = (reader.readBit() > 0);

		var pictureId = reader.readIntegerFromBits(6); // ?
		var visible = new ThingDetailsVisible
		(
			pictureId
		);

		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		var carryable = new ThingDetailsCarryable
		(
			weight,
			value,
			magical,
			"todo-disappearsWhenDropped",
			diesOnUse,
			onlyOwnerCanUse
		);

		return new ThingDetailsArmor
		(
			visible,
			carryable,
			armorDetails
		);
	}
}

class ThingDetailsArmorDetails
{
	constructor
	(
		power,
		range,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage
	)
	{
		this.power = power;
		this.range = range;
		this.attackAdjustmentAsPercentage =
			attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage =
			chanceOfBreakingAsPercentage;
	}

	static fromBytes(reader)
	{
		var range = reader.readIntegerFromBits(3) + 2;
		var power = reader.readIntegerFromBits(5);
		var attackAdjustmentEncoded =
			reader.readIntegerFromBits(4);
		var attackAdjustmentAsPercentage = 
			attackAdjustmentEncoded * 5 - 35;
		var chanceOfBreakingAsPercentage =
			reader.readIntegerFromBits(4);

		return new ThingDetailsArmorDetails
		(
			power,
			range,
			attackAdjustmentAsPercentage,
			chanceOfBreakingAsPercentage
		);
	}
}

class ThingDetailsCarryable
{
	constructor
	(
		weight,
		value,
		magical,
		disappearsWhenDropped,
		disappearsWhenUsed,
		disappearsWhenHolderDies
	)
	{
		this.weight = weight;
		this.value = value;
		this.magical = magical;
		this.disappearsWhenDropped = disappearsWhenDropped;
		this.disappearsWhenUsed = disappearsWhenUsed;
		this.disappearsWhenHolderDies = disappearsWhenHolderDies;
	}
}

class ThingDetailsDevice
{
	// "Magic Item".

	constructor
	(
		triggersWhenPickedUp,
		triggersWhenUsed,
		triggersWhenDropped,
		effectWhenTriggered
	)
	{
		this.effectWhenUsed = effectWhenUsed;
	}
}

class ThingDetailsEffector
{
	// "Magic Spell".
	constructor()
	{
		this.powerToTrigger = powerToTrigger;
		this.effectWhenTriggered = effectWhenTriggered;
	}
}

class ThingDetailsObstacle
{
	constructor(effectWhenBumped)
	{
		this.effectWhenBumped = effectWhenBumped;
	}
}

class ThingDetailsSpace
{
	constructor
	(
		itemNeededToPassId,
		itemNeededToPassIsDestroyed,
		itemForbiddenToPassId,
		textToShowWhenBlocked,
		effectWhenSteppedOn
	)
	{
		this.itemNeededToPassId = itemNeededToPassId;
		this.itemNeededToPassIsDestroyed =
			itemNeededToPassIsDestroyed;
		this.itemForbiddenToPassId = itemForbiddenToPassId;
		this.textToShowWhenBlocked = textToShowWhenBlocked;
		this.effectWhenSteppedOn = effectWhenSteppedOn;
	}
}

class ThingDetailsSpaceCustom
{
	constructor()
	{
		// todo
	}
}

class ThingDetailsStore
{
	constructor()
	{}
}

class ThingDetailsTreasure
{
	constructor(visible, carryable)
	{
		this.visible = visible;
		this.carryable = carryable;
	}

	static fromBytes(reader)
	{
		var pictureId = reader.readIntegerFromBits(6); // ?
		var visible = new ThingDetailsVisible
		(
			pictureId
		);

		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		var carryable = new ThingDetailsCarryable
		(
			weight,
			value,
			null, // magical,
			"todo-disappearsWhenDropped",
			null, // diesOnUse,
			null // onlyOwnerCanUse
		);

		return new ThingDetailsTreasure
		(
			visible,
			carryable
		);
	}
}


class ThingDetailsUsable
{
	constructor(durable)
	{
		this.durable = durable;
	}
}

class ThingDetailsVisible
{
	constructor(pictureId)
	{
		this.pictureId = pictureId;
	}
}

class ThingDetailsWeapon
{
	constructor
	(
		power,
		range,
		attackAdjustmentAsPercentage,
		chanceOfBreakingAsPercentage
	)
	{
		this.power = power;
		this.range = range;
		this.attackAdjustmentAsPercentage =
			attackAdjustmentAsPercentage;
		this.chanceOfBreakingAsPercentage =
			chanceOfBreakingAsPercentage;
	}

	static fromBytes(reader)
	{
		var range = reader.readIntegerFromBits(3) + 2;
		var power = reader.readIntegerFromBits(5);
		var attackAdjustmentEncoded =
			reader.readIntegerFromBits(4);
		var attackAdjustmentAsPercentage = 
			attackAdjustmentEncoded * 5 - 35;
		var chanceOfBreakingAsPercentage =
			reader.readIntegerFromBits(4);

		return new ThingDetailsWeapon
		(
			power,
			range,
			attackAdjustmentAsPercentage,
			chanceOfBreakingAsPercentage
		);
	}
}

class ThingDetailsWeaponMelee
{
	constructor(visible, carryable, weapon)
	{
		this.visible = visible;
		this.carryable = carryable;
		this.weapon = weapon;
	}

	static fromBytes(reader)
	{
		var weapon =
			ThingDetailsWeapon.fromBytes(reader);

		var magical = (reader.readBit() > 0);
		var onlyOwnerCanUse = (reader.readBit() > 0);

		var pictureId = reader.readIntegerFromBits(6); // ?
		var visible = new ThingDetailsVisible
		(
			pictureId
		);

		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		var carryable = new ThingDetailsCarryable
		(
			weight,
			value,
			magical,
			"todo-disappearsWhenDropped",
			diesOnUse,
			onlyOwnerCanUse
		);

		return new ThingDetailsWeaponMelee
		(
			visible,
			carryable,
			weapon
		);
	}
}

class ThingDetailsWeaponMissile
{
	constructor(visible, carryable, weapon)
	{
		this.visible = visible;
		this.carryable = carryable;
		this.weapon = weapon;
	}

	static fromBytes(reader)
	{
		var weapon =
			ThingDetailsWeapon.fromBytes(reader);

		var magical = (reader.readBit() > 0);
		var onlyOwnerCanUse = (reader.readBit() > 0);

		var pictureId = reader.readIntegerFromBits(6); // ?
		var visible = new ThingDetailsVisible
		(
			pictureId
		);

		var diesOnUse = reader.readBit() > 0;
		var weight = reader.readIntegerFromBits(15);
		var value = reader.readIntegerFromBits(16);

		var carryable = new ThingDetailsCarryable
		(
			weight,
			value,
			magical,
			"todo-disappearsWhenDropped",
			diesOnUse,
			onlyOwnerCanUse
		);

		return new ThingDetailsWeaponMissile
		(
			visible,
			carryable,
			weapon
		);
	}
}

class ThingType
{
	constructor(id, name, detailsFromBytes)
	{
		this.id = id;
		this.name = name;
		this._detailsFromBytes = detailsFromBytes;
	}

	static Instances()
	{
		if (this._instances == null)
		{
			this._instances = new ThingType_Instances();
		}

		return this._instances;
	}

	static byId(id)
	{
		return this.Instances().byId(id);
	}

	detailsFromBytes(reader)
	{
		return this._detailsFromBytes(reader);
	}
}

class ThingType_Instances
{
	constructor()
	{
		var tt = (id, name, detailsFromBytes) =>
			new ThingType(id, name, detailsFromBytes);

		this.RoomFloor 			= tt(0, "Room Floor",		this.detailsFromBytes_Todo);
		this.Treasure 			= tt(1, "Treasure", 		this.detailsFromBytes_Treasure);
		this.MagicItem 			= tt(2, "Magic Item", 		this.detailsFromBytes_Todo);
		this.MissileWeapon 		= tt(3, "Missile Weapon", 	this.detailsFromBytes_MissileWeapon);
		this.MeleeWeapon 		= tt(4, "Melee Weapon", 	this.detailsFromBytes_MeleeWeapon);
		this.Armor 				= tt(5, "Armor", 			this.detailsFromBytes_Armor);
		this.MagicSpell 		= tt(6, "Magic Spell", 		this.detailsFromBytes_Todo);
		this.Portal 			= tt(7, "Portal", 			this.detailsFromBytes_Todo);
		this.Space 				= tt(8, "Space", 			this.detailsFromBytes_Todo);
		this.CustomSpace		= tt(9, "Custom Space", 	this.detailsFromBytes_Todo);
		this.Obstacle			= tt(10, "Obstacle", 		this.detailsFromBytes_Todo);
		this.CustomObstacle 	= tt(11, "Custom Obstacle", this.detailsFromBytes_Todo);
		this.Store 				= tt(12, "Store", 			this.detailsFromBytes_Todo);

		this._All =
		[
			this.RoomFloor,
			this.Treasure,
			this.MagicItem,
			this.MissileWeapon,
			this.MeleeWeapon,
			this.Armor,
			this.MagicSpell,
			this.Portal,
			this.Space,
			this.CustomSpace,
			this.Obstacle,
			this.CustomObstacle,
			this.Store
		];
	}

	byId(id)
	{
		return this._All.find(x => x.id == id);
	}

	// Properties.

	detailsFromBytes_Todo(reader)
	{
		return "todo";
	}

	detailsFromBytes_Armor(reader)
	{
		return ThingDetailsArmor.fromBytes(reader);
	}

	detailsFromBytes_MeleeWeapon(reader)
	{
		return ThingDetailsWeaponMelee.fromBytes(reader);
	}

	detailsFromBytes_MissileWeapon(reader)
	{
		return ThingDetailsWeaponMissile.fromBytes(reader);
	}

	detailsFromBytes_Treasure(reader)
	{
		return ThingDetailsTreasure.fromBytes(reader);
	}

}

class WorldMap
{
	constructor
	(
		name,
		wrappingIsAllowed,
		entryPoint,
		terrainDefinitions,
		creatureOccurrences,
		sizeInCells,
		cellsAsTerrainIndexRows
	)
	{
		this.name = name;
		this.wrappingIsAllowed = wrappingIsAllowed;
		this.entryPoint = entryPoint;
		this.terrainDefinitions = terrainDefinitions;
		this.creatureOccurrences = creatureOccurrences;
		this.sizeInCells = sizeInCells;
		this.cellsAsTerrainIndexRows = cellsAsTerrainIndexRows;
	}

	terrainAtPosInCells(posInCells)
	{
		var terrainIndex =
			this.terrainIndexAtPosInCells(posInCells);
		var terrain = this.terrainDefinitions[terrainIndex];
		return terrain;
	}

	terrainIndexAtPosInCells(posInCells)
	{
		var cellTerrainIndexRow =
			this.cellsAsTerrainIndexRows[posInCells.y];
		var cellTerrainIndex =
			cellTerrainIndexRow[posInCells.x];
		return cellTerrainIndex;
	}

	toCanvas(adventure)
	{
		var d = document;

		var mapSizeInCells = this.sizeInCells;
		var pictureSizeInPixels = Picture.sizeInCells();
		var cellSizeInPixels = pictureSizeInPixels;
		var mapSizeInPixels =
			mapSizeInCells
				.clone()
				.multiply(cellSizeInPixels);

		var mapAsCanvas = d.createElement("canvas");
		mapAsCanvas.width = mapSizeInPixels.x;
		mapAsCanvas.height = mapSizeInPixels.y;
		var graphics = mapAsCanvas.getContext("2d");

		var cellPosInCells = new Coords(0, 0);
		var drawPosInPixels = new Coords(0, 0);
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < mapSizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellTerrain =
					this.terrainAtPosInCells(cellPosInCells);

				drawPosInPixels
					.overwriteWith(cellPosInCells)
					.multiply(cellSizeInPixels);

				var cellTerrainPicture =
					cellTerrain.picture(adventure);
				var cellTerrainPictureAsCanvas =
					cellTerrainPicture.toCanvas();

				graphics.drawImage
				(
					cellTerrainPictureAsCanvas,
					drawPosInPixels.x, drawPosInPixels.y
				);
			}
		}

		return mapAsCanvas;
	}

	// Bytes.

	static fromBytes(bytes)
	{
		// Start with 0x1C000.

		var reader = BitStream.fromBytes(bytes);
		var converter = new ByteConverter();

		reader.byteIndexSet(0x42C);
		var wrappingIsAllowed =
			reader.readByte() > 0;

		var name =
			converter.bytesToString(reader.readBytes(20) );

		reader.byteIndexSet(0x700 + 234); // hack
		var mapSizeInCells = new Coords(40, 40);
		var bitsPerCell = 4; // 16 terrains.
		var mapCellsCount =
			mapSizeInCells.x
			* mapSizeInCells.y;
		var bitsPerByte = 8;
		var mapCellsSizeInBytes =
			mapCellsCount * bitsPerCell / bitsPerByte;
		var mapCellPairsAsBytes =
			reader.readBytes(mapCellsSizeInBytes);
		var terrainIndicesForCells = [];
		for (var i = 0; i < mapCellPairsAsBytes.length; i++)
		{
			var cellPairAsByte = mapCellPairsAsBytes[i];
			var cellLeftTerrainIndex =
				cellPairAsByte >> 4;
			var cellRightTerrainIndex =
				cellPairAsByte & 0x0F;
			terrainIndicesForCells.push(cellLeftTerrainIndex);
			terrainIndicesForCells.push(cellRightTerrainIndex);
		}

		var cellsAsTerrainIndexRows = [];
		var cellsPerRow = mapSizeInCells.x;
		for (var y = 0; y < mapSizeInCells.y; y++)
		{
			var cellIndexStart = y * cellsPerRow;
			var cellIndexEnd =
				cellIndexStart + cellsPerRow;

			var terrainIndexRow =
				terrainIndicesForCells
					.slice(cellIndexStart, cellIndexEnd);
			cellsAsTerrainIndexRows
				.push(terrainIndexRow);
		}

		reader.byteIndexSet(0x7a0);
		var playerEntryPoint = new Coords
		(
			reader.readByte(), reader.readByte()
		);

		var td = (id, name) => new WorldMapTerrain(id, name, id, null);
		var terrainDefinitions =
		[
			td(0,	"Water"),
			td(1,	"Plain"),
			td(2,	"Swamp"),
			td(3,	"Desert"),
			td(4,	"Dense Forest"),
			td(5,	"Forest"),
			td(6,	"Chapparal"),
			td(7,	"Fields"),
			td(8,	"Mountains"),
			td(9,	"Foothills"),
			td(10,	"River"),
			td(11,	"High Mountains"),
			td(12,	"Gateway"),
			td(13,	"Parapet Gateway"),
			td(14,	"Castle"),
			td(15,	"Old Church")
		];

		var creatureOccurrences = []; // todo
		/*
		reader.byteIndexSet(0xb0a);
		var creatureOccurrenceSizeInBytes = 592; // ?
		var creatureOccurrencesCount = 8;
		for (var i = 0; i < creatureOccurrencesCount; i++)
		{
			var creatureOccurrenceAsBytes =
				reader.readBytes(creatureOccurrenceSizeInBytes);
		}
		*/

		var worldMap = new WorldMap
		(
			name,
			wrappingIsAllowed,
			playerEntryPoint,
			terrainDefinitions,
			creatureOccurrences,
			mapSizeInCells,
			cellsAsTerrainIndexRows
		);

		return worldMap;
	}

	toBytes()
	{
		throw new Error("todo");
	}
}

class WorldMapCreatureOccurrence
{}

class WorldMapTerrain
{
	constructor(id, name, pictureId, passability)
	{
		this.id = id;
		this.name = name;
		this.pictureId = pictureId;
		this.passability = passability;
	}

	picture(adventure)
	{
		return adventure.pictureById(this.pictureId);
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}

}

class WorldMapTerrainPassability
{
	constructor()
	{
		// todo
	}

	// Bytes.

	static manyFromBytes(bytes)
	{
		throw new Error("todo");
	}

	static fromBytes(bytes)
	{
		throw new Error("todo");
	}

	toBytes()
	{
		throw new Error("todo");
	}
}



</script>