An Exploration of the
Adventure Construction Set
Adventure File Format
==========================

This document records research into the format of the ACS
"adventure file".  The information in it was gathered by
creating a blank "fantasy" adventure, copying the ADVEN.HRD
file elsewhere, making a slight change to it in the ACS editor,
then comparing the new ADVEN.HRD to the previous copy using
the Windows command

	fc /b ADVEN.HRD ADVEN-Copy.hrd

then examining each group of changed bytes in a hex editor.



Scenario Type: Fantasy

Images
------

Images are 16 x 16, and can use a palette of four colors,
by default, black, white, blue, and brown.
A palette slot can be filled by any of 16 colors,
which perhaps correspond to old console colors.

Terrain Pictures (or Things & Creatures)
0	Water
1	Plain
2	Swamp
3	Desert
4	Dense Forest
5	Forest
6	Chapparal?
7	Fields
8	Mountains
9	Foothills
10	River
11	High Mountains
12	Gateway
13	Parapet Gateway
14	Castle
15	Old Church

Thing Pictures (or Terrain and Creatures)

Chest
Hut
Door
Stone Wall
Heap?
Chair
Helmet
Ring
Painting
Key
Person with Skirt
Marble?

[row break, 12 so far]

Dart?
Shield
Crown
Axe
Trident
Dagger
Sword
Goblet
Bow
Carpet
Pot?
Chair2

[row, 24]

Scroll
Wand?
Oil Lamp
Steps
Bed
Table
Flowers?
Ham?  Flask?
Bottle
Ladder
Torch
Red Cross

[row, 36]

Lantern
Armor
Crossbow
Bowl of Fruit
Pack?
Snake?
Horse
Banner?
Eye
Candelabra
?
Heiroglyphs

[48]

Creature Pictures (Only)

King
Lady
Giant
Wizard
Ghost
Swordsman
Jester
Snake
Crone
Vizier
Gryphon
Devil

[row, 12]

Bee
Lady2
Thief
Troubadour
Goblin?
Priest
Rogue?
Man in Peaked Hat
Dragon
Witch
Caveman
Bird

[row, 24]

Troll?
Bat
Troll2?
Golem?
Centaur
Mermaid
Tree Creature
Merman
Man with Amulet
Fairy
Spider
Rat

[row, 36]

Eyeball with Tentacles
Lion?
Rock
Pegasus
Snake2
Fire Spirit?
Unicorn
Minotaur
Skeleton
Skull

[10]

[46?]

94?
+ 16 terrain 
= 100 pictures total?



Things
------

Types
-----

Code	Name
----	----
Ar		Armor
Co		Custom Obstacle
Cs		Custom Space
Ma		Magic Item
Me		Melee Weapon
Mi		Missile Weapon
Ms		Magic Spell
Ob		Obstacle
Po		Portal
Rf		Room Floor
Sp		Space
St		Store
Tr		Treasure

Number	Type	Name
------	----	----
1		Mi 		Oil and Wick
2		Me		Dagger
3 		Mi		Blessed Water

[4]

5		Ma		Food Container
6		Tr		Jewel Packet
7		Tr		Diamond Packet
8		Me		Horn
9		Me		Fang Attack
10		Me		Hoof
11		Me		Claw
12		Me		Hand
13		Me		Stone Touch
14		Mi		Firebreathing
15 		Mi		Stone Gaze
16		Mi		Cry of Undead
17		Ar		Thick Scales
18		Ar		Thick Skin
19		Ma		Magic Lamp
20		Tr		Crown of Kaunas
21		Ma		Poison
22		Tr		Kdnp'd Princess

[23-32]

33		Ar		Scroll
34		Me		Magic Sword
35		Tr		Horse
36		Ma		Potion
37		Me		Battle Axe
38		Me		Long Sword
39		Me		Flail
40		Me		Mace
41		Me		Short Sword
42		Me		Club
43		Me		Trident
44		Mi		Crossbow
45		Mi		Msear
46		Mi		Magic Bow
47		Mi		Bow-Silver Arr.
48		Mi		Bow and Arrow
49		Ar		Plate Mail
50		Ar		Chain Mail
51		Ar		Heavy Shield
52		Ar		Leather Armor
53		Ar		Light Shield
54		Ar		Helmet
55 		Ma		Magic Ring
56		Ma		Shield of Honor
57		Ma		Scroll
58		Ms		Blessing
59		Ms		Curse
60		Ms		Weakness
61		Ms		Flight
62		Ms		Give Armor
63		Ms		Give Weapon
64		Ms		Life
65		Ms		Mseed
66		Ms		Swim
67		Ma		Potion
68		Ma		Scroll
69		Ma		Magic Wand
70		Ma		Magic Ring
71		Ma		Magic Staff
72		Ma		Magic Wand
73		Tr		Key
74		Tr		Rope
75		Tr		Lantern
76		Tr		Magic Bag
77		Tr		Packet
78		Me		Deadly Touch
79		Me		Acid Touch
80		Ms		Do nothing
81		Tr		Gold
82		Po		Standard Door
83		St		Store
84		Po		One-Way Door
85		Sp		Chasm
86		Ob		Wall
87		Co		Trap
88		Ob		Poisoned Chest
89		Ob		Medicinal Cache
90		Ob		Table
91		Ob		Trees
92		Po		Trap Door
93		Po		Locked Door
94		Po		Hidden Door
95		Po		Stairs
96		Sp		Int Door-Locked
97		Sp		Interior Door
98		Sp		Darkness
99		Sp		Siren Flowers
100		Sp		Bed
101		Sp		Chair
102		Co		Treasure Chest
103		Cs		Trap
104		Sp		Mountains
105		Sp		Water
106		Ob		Blank Wall
107		Cs		Altar
108		Po		Massive Boulder
109		Cs		Message Space
110		Cs		Music Space
111		Cs		Rid Room Space
112		Cs		Add 2 Rm. Space
113		Cs		Creature Space
114		Cs		Life Force Space
115		Cs		Consume-Carry
116		Ob		Do All-Bump
117		Sp		Do All-Walk
118		Sp		Neptune's Pool
119		Po		Invisible Door
[120-126]
127		Rf		Empty Floor

Thing Editing
-------------
1 - Oil and Wick

Beings
------

Types
-----
1	PF	Persons-Friends
2	PE	Persons-Enemies
3	PN	Persons-Neutral
4	PT	Persons-Thieves
5	BH	Beasts-Hostile
6	BN	Beasts-Neutral
7	EB	Evil Beings
8	YN	Your New Idea

Id	Name			Type
--	----			----
1	Achilles		PF
2	Ali Baba		PF
3	Centaur			PN
4	Assassin		PE
5	Berserker		PE
6	Bugbear			PE
7	Adept			PN
8	Bandit			PT
9	Banshee			EB
10	Troubadour		PT
11	Basilisk		BH
12	Bear			BH
13	Callisto		PE
14	Chestmonster	BH
15	Chimera			BH
16	Cleric			PN
17	Evil Cleric		PE
18	Conquistador	PE
19	Cyclops			PE
20	Demon			EB
21	Doppleganger	PE
22	Dragon			BH
23	Druid			PN
24	Dryad			PN
25	Dwarf			PN
26	Eagle			BN
27	Elf				PN
28	Floating Eye	BH
29	Ghost			EB
30	Ghoul			EB
31	Giant			PE
32	Gnome			PN
33	Goblin			PE
34	Golem			EB
35	Gorgon			BH
37	Grue			BH
38	Guard			PE
39	Guard Captain	PE
40	Halfling		PN
41	Harpy			BH
43	Hippocampus		BN
45	Hydra			BH
42	Heracles		PF
44	Hobgoblin		PE
46	Hyena Man		PE
47	Conjurer		PN
48	King			PN
49	King Arthur		PF
50	Knight			PN
51	Kobold			PE
52	Leprechaun		PT
53	Lion			BH
54	Lizoid			PE
55	Llorona			EB
56	Magician		PN
57	Evil Magician	PE
58	Medusa			PE
59	Merchant		PN
60	Merlin			PF
61	Mermaid			PN
62	Minotaur		EB
63	Outcast Monk	PT
64	Mummy			EB
65	Odysseus		PF
66	Ogre			PE
67	Orc				PE
68	Lone Paladin	PN
69	Pegasus			BN
70	Pixie			PN
71	Ranger			PN
72	Giant Rat		BH
73	Roc				BH
74	Salamander		EB
75	Samurai			PN
76	Satyr			PN
77	Siren			EB
78	Sir Lancelot	PF
79	Skeleton		EB
80	Slime			BH
81	Giant Snake		BH
82	Specter			EB
83	Sphinx			BN
84	Giant Spider	BH
85	Sprite			PN
86	Stonestalker	EB
87	Thief			PT
88	Treeman			PN
89	Triton			PN
90	Troll			PE
91	Unicorn			BN
92	Vampire			EB
93	Vulture Boulder	BH
94	Warrior			PN
95	Giant Werebee	BH
96	Werewolf		EB
97	Wight			EB
98	Giant Worm		BH
99	Wraith			EB
100	Zombie			EB
101	Wallmonster		BH

Terrains
--------

Number	Name				Symbol		Notes
------	----				------		-----

1		Water				~
2		Plains				.
3		Swamp				s
4		Desert				d
5		Dense Forest		F
6		Forest				f
7		Chapparal			c
8		Fields				=
9		Mountains			m
10		Foothills			h
11		River				r
12		High Mountains		M
13		Gateway				g			Must specify "door destination".
14		Parapet Gateway		G			"
15		Castle				C			"
16		Old Church			t			"

By default, only Water is impassable,
and other terrains are "open to all".

In the demo,
River has been made open to owners of the spell "Swim" (66),
while the High Mountains are passable to owners of the spell "Flight" (61).


Terrain Passability Options
---------------------------

Number	Description ("Which...")
------	------------------------
1		...is impassable terrain.
2		...is open to travel by all.
3		...is only open to owners of object-spell [thing]
4		...triggers the spell [magic spell]


Demo World Map
--------------

Name: WORLDMAP

Size is 40 by 40, which is 1600 cells.

Player entry point is 0x1.

Movement off the edge of map is not permitted, which is the default.

The "door destinations" for the g, G, C, and t cells
are all 1 cell south of the door terrain itself.

~.sdFfc=mhrMgGCt.~.~.~.~.~.~.~.~.~.~.~.~
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................
~.......................................
........................................


Map Creatures
-------------
8 Slots

Slot 1 - Achilles

	Appearing in Dense Forest

	Traits

		[Image: Guy with Sword]

		Constitution	27> 	28		1-63 (6 bits)
		Wisdom			13		15		0-31 (5 bits)
		Strength		16>		19		0-31
		Dexterity		15		19		0-31
		Missile Skill	44>		49		0-127 (7 bits)
		Melee Skill		67>		73		0-127

		Wealth			500>	516		0-25000 (15 bits)

		Life Force		27>		35		1-63
		Power			13		22		0-127
		Size			11		21		0-31
		Armor Skill		20		31		0-127
		Dodge Skill		34		46		0-127
		Parry Skill		38		51		0-127

		Speed			7		8		0-15

		Only magic weapons do damage
		Readied Weapon: Spear
		Readied Armor: Scroll
		Strategy: Brave Agressive Friends
		Will Not Mimic All Powers of its Victim

		Possessions
			Dagger
			Food Container (3)
			Claw
			Hand
			Scroll (Armor)
			Horse
			Short Sword
			Spear
			Leather Armor
			Helmet

		Appears 2 per cent of the time

W.P.S.D.F

Field				Offset				Length	Values 					Notes
-----				------				------	-----					-----
thing 1
	name			0x1b800-09			10		ABCDEFGHIJKLMNO			?
	ct. generated	0x1c000.hi			4bits	0-14 + infinite			?
	power			0x1c087				?		0-31					?
	range			0x1c087.hi5?		1		0-31					?
	attack adj.		0x1c088.hi?			? 		-35% to 40% x 5%
	chance break	0x1c088.lo?			?		0% - 15%
	is magic		0x1c089.hi.1		1 bit	?
	only owner uses 0x1c089.hi.2		1 bit	?
	picture			0x1c089.low6?		6 bits?	?						?
	dies on use		0x1bd00.hi.lowest	1 bit	?
	weight			0x1bd00-1?			2?		-5000 to 5000			?
	value			0x1bd02				2		0 to 5000				?
	max held?									always 3 for missile weapons?

thing 2
	name			0x1b80A-D			4		0						changed "dagger" to blank

adventure name 		0x1c200-1c213		20		?						Padded with spaces.
author				0x1c214-1c227		20		?						"
message 1 of 254	0x06c00-06d00		0x100	?						"
message 2 of 254	0x16900				0x100	?						"
intro message		0x16a00				0x100	?						"
musical theme id	0x1c56e				1		00 (fantasy), 01 (spy)	?
world map name		0x1c42d-1c441		?		?						"
date/time saved?	0x1c600-01			2		?						Changes every save.
world map terrain?	0x1c700				?		?						?
world map wraps		0x1c42c				1		01 (wrap)				?
start point x,y		0x1c7a0-1			2		0, 0 NW corner			?
monster attrib?		0x1cb0a-2b			?		?						?
	const			0x1cb0a.0-5
	?
	wisdom			0x1cb1b.0-4
	?
monster terrain		0x1cd5a.hi			?		1(plain), 4(dforest)	?
monster percent		0x1cd5a.lo			?		2% = 1, 4% = 2, etc.	?
?					0x1ce52-57			?


Creature Definitions
--------------------

I changed the blank fantasy adven.hrd
by prefixing the name of the first two creatures,
namely, Achilles and Ali Baba,
with 1 and 2 respectively.
Then, the file compare shows these differences
(minus the two bytes that ALways change):

	1B280: C0 EB
	1B281: 06 A8
	1B282: 2C 74
	1B283: 3A 33
	1B284: 38 DB
	1B285: 22 4B

	1B28A: 29 34
	1B28B: 08 AF
	1B28C: 51 42
	1B28D: 00 38
	1B28E: A8 91
	1B28F: 0C 06

So, two sets of six bytes,
separated by just ten bytes.
Darn, all the names are listed separate, huh?

Okay, I restored the names
and upped Achilles and Ali Baba's constitution scores
by 1 (I think) each.
Here's that diff:

	19400: 9B 9C
	19425: 0F 11

Yeesh, that's a long way off
from the names.
And it precedes them, surprisingly.
So they're 0x25 = 37 bytes apart.
That's a strange number.
They must be really packed in there.

(Backing up a bit,
I changed his creature class
from Persons-Friends to Persons-Enemies:)

	0001B200: 10 11

All right, now it's reading all the creature names,
and evidently the constitutions.
I maxed out Achilles' constitution (from 27 to 63):

	00019400: 9B BF
	0x9B = 0b1001_1011 = 9 * 16 + 11 = 151
	0xBF = 0b1011_1111 = 11 * 16 + 15 = 176 + 15 = 191

Constitution seems to share a byte
with magic damage resistance?
From "only magic weapons do damage"
to "non-magic weapons do half damage":

	00019400: 9B 5B

	0x9B = 0b1001_1011
	0x5B = 0b0101_1011

to "MAGIC weapons do half damage":

	00019400: 9B DB

	0xDB = 0b1101_1011

to "no magic defense":

	00019400: 9B 1B

	0x1B = 0b0001_1011

Next strength from 16? to 31:
(16 seems a bit low for Achilles...)

	00019401: 10 1F

Next dexterity from 15 to 31:

	00019402: 0F 1F

Here's life force, from 27 to 63:

	19403: 1B 3F

Speed, from 7 to 15:

	00019404: F7 FF

Speed seems to share a byte
with Strategy.
Changed "Strategy" from "Brave" to "Cautious":

	00019404: F7 77

"Aggressive" to "peaceful":

	00019404: F7 B7

"Friend" to "Thief":

	00019404: F7 C7
	0xF7 = 0b1111_0111
	0xC7 = 0b1010_0111

...to "Neutral":

	00019404: F7 D7

	0xD7 = 0b1101_0111

...to "Enemy":

	00019404: F7 E7
	0xE7 = 0b1110_0111


And power, from 13 to 127:

	00019405: 0D 7F

Dodge skill, from 34 to 127:

	00019406: 22 7F

Parry, from 38 to 127:

	00019407: 26 7F

Armor skill, from 20 to 127:

	00019408: 14 7F

Now his melee skill,
from 67 to 127:

	00019409: 43 7F

Melee skill seems to share a byte
with mimicry.
"Will not mimic..." to "Will Mimic..."

	00019409: 43 C3

	0100 -> 1100
	So, the top bit?

I guess these aren't bitfields?
They just leave some bits unused?
That'd be a relief, if true.
Anyway, here's missile skill,
from 44 to 127:

	0001940A: 2C 7F

Then bytes -B from -E don't seem to change,
then

Size, from 11 to 31:

	0001940F: 0B 1F

Then we skip -10, then

Then wisdom (fom 13 to 31),
and this is the result:

	00019411: 0D 1F

Then his wealth,
from 500 to 25,000:

	00019412: F4 A8
	00019413: 01 61

	0x01F4 = 256 + 15 * 16 + 4
		   = 256 + 240 + 4
		   = 256 + 244
		   = 400 + 90 + 10
		   = 500

That one seems a bit tricky,
so here's it set to 0 instead:

	00019412: F4 00
	00019413: 01 00

Readied Weapon
from "Spear" to "None":

	00019414: 2D 00

...to "Dagger":

	00019414: 2D 02

...to "Hand":

	00019414: 2D 0C

These do seem to be the IDs of the items.

Changed "Readied Armor"
from "Scroll" to "Leather Armor":

	00019415: 21 34

Then I moved to the next picture:

	00019416: 47 48


Regions
-------

Added new region "RegionRegionRegion01",
with no rooms.
It modified like 50ish bytes
in various places.

0001C229: 00 01

1C441: 41 52 // These are the name.
1C442: 43 45
1C443: 53 47
1C444: 20 49
1C445: 57 4F
1C446: 49 4E
1C447: 4C 52
1C448: 4C 45
1C449: 20 47
1C44A: 50 49
1C44B: 49 4F
1C44C: 43 4E
1C44D: 4B 52
1C44E: 20 45
1C44F: 4E 47
1C450: 41 49
1C451: 4D 4F
1C452: 45 4E
1C453: 20 30
1C454: 20 31

1D301: 00 A5 // Unknown what these are.
1D302: 00 05
1D303: 00 F0
1D305: 00 F2
1D307: 00 92
1D308: 00 01

1D885: 00 02
1D887: 00 02
1D889: 00 02
1D88B: 00 02
1D88D: 00 02
1D88F: 00 02
1D891: 00 02
1D893: 00 02
1D895: 00 02
1D897: 00 02
1D899: 00 02
1D89B: 00 02
1D89D: 00 02
1D89F: 00 02
1D8A1: 00 02
1D8A3: 00 02

Field			Offset			Size		Values			Notes
-----			------			----						-----
Region Count?	0x1C229			1 byte		
Region Name		0x1C441-454		20 bytes
?				0x1D301-308		8 bytes
?				0x1D885-1D8A3	?			All 0002's.		Skips every other byte.




Rooms
-----

Added a room of default size (3x3)
to RegionRegionRegion01,
at the upper-left corner,
named RoomRoomRoom001.
Its auto-assigned ID, from the UI, seems to be 16.
That modified like 18-20 bytes.
(Weirdly, it didn't seem to modify the two it always does.)

0001D300: 00 01
0001D309: 00 13
0001D30A: 00 22

0001D6F3: 00 E7
0001D6F4: 00 72
0001D6F5: 00 1F
0001D6F6: 00 54
0001D6F7: 00 DA
0001D6F8: 00 5F
0001D6F9: 00 25
0001D6FA: 00 60
0001D6FB: 00 33
0001D6FC: 00 60

Then I enlarged to max size (15x10)
and here's the changes:
(This time it did change those two bytes it always does.)

0001D300: 00 01
0001D309: 00 13
0001D30A: 00 E9 // Okay, clearly the (decremented) size is here.

0001D6F3: 00 E7
0001D6F4: 00 72
0001D6F5: 00 1F
0001D6F6: 00 54
0001D6F7: 00 DA
0001D6F8: 00 5F
0001D6F9: 00 25
0001D6FA: 00 60
0001D6FB: 00 33
0001D6FC: 00 60


There seemed to be a lot of bytes in the middle already.

Field			Offset			Size		Values			Notes
-----			------			----		-------			-----
Room count? ID?	0x1d300			1 bytes		1
				0x1D309-C		4 bytes		13 22 27 13
Name?			0x1D6F3-C		10 bytes	E7 72 1F 54 DA
											5F 25 60 3D AD

I temporarily changed the room name to roomroomroom122,
and then this was different:

	0001D6FB: 3D 3C

Rooms have
random creatures,
resident creatures,
and "contents".

A room has 8 Random Creature slots.
"A master table creature"
I added "1-Achilles",
with a 5/75 (x5) percent chance of appearing.
I also added a "Banshee",
and it seems that you can't delete it
once you've added one.
So I rolled that back
and re-made the Achilles.
Here's the diff:

0001D30D: 00 01 // creature number?
0001D37B: 00 9B // attributes?
0001D37C: 00 10
0001D37D: 00 0F
0001D37E: 00 1B
0001D37F: 00 F7
0001D380: 00 8D
0001D381: 00 22
0001D382: 00 26
0001D383: 00 14
0001D384: 00 43
0001D385: 00 2C
0001D38A: 00 0B
0001D38C: 00 0D
0001D38D: 00 F4
0001D38E: 00 01 // Chance of appearance?
0001D38F: 00 2D
0001D390: 00 21
0001D391: 00 47
0001D392: 00 10
0001D393: 00 C0
0001D394: 00 01 // Chance of appearance?
0001D39A: 00 A0
0001D39B: 00 88
0001D39C: 00 14
0001D793: 00 C0
0001D794: 00 06
0001D795: 00 2C
0001D796: 00 3A
0001D797: 00 38
0001D798: 00 22


The room layout has:

wall picture
add many things
add one thing
delete thing
examine room
add creature


Presumably this is the same format
as for the wandering monsters on the world map?


Pictures
--------

Changing a single pixel on the first image ("water"),
namely, changing the pixel at the upper right
from black (color 0?) to blue (color 1?)
leads to these changes:

	[0x1c600-1: random changes as always, omitting going forward]

	00028720: 00 40

	00029688: 06 04
	00029689: 06 07
	[skips -A?]
	0002968B: 12 0C
	0002968C: 05 04
	0002968D: 13 20
	0002968E: 14 20

Then, if I change it BACK to black,
it still leaves these changes:

	00029688: 06 04
	00029689: 06 07

	0002968B: 12 0C
	0002968C: 05 04
	0002968D: 13 20
	0002968E: 14 20

Sigh.  What's with THIS weirdo encoding?
There are only four colors,
which fit perfectly into two bits,
four sets of which fit perfectly in a byte.
It seems that fancier encoding is pointless.
Maybe this is some sort of dirty flag?
Or maybe per-row/ per-column checksum?

What if I do the same
to picture #2?
It's "plains",
which is completely black.
I added a blue pixel in the upper left.
Then the diff becomes:

	00028730: 00 40

	00029688: 06 04
	00029689: 06 07

	0002968B: 12 0C
	0002968C: 05 04
	0002968D: 13 20
	0002968E: 14 20

The other bytes didn't change again.
I don't know what they are,
but I'm gonna assume they don't matter.

I calculate each picture as 64 bytes minimum:

	16 pixels across
	* 16 pixels down
	* 2 bits/pixel
	/ 8 bits/byte
	=
	64 bytes

The actual substantive changes
would therefore be:

	0x28730
	- 0x28720
	=
	0x10
	=
	16.

So, from this, it appears
that corresponding pixels in adjacent pictures
are 16 bytes apart,
which would imply that each picture
is 16 bytes long.
But that can't be right, because
I calculated 64 bytes!
(Assuming no compression,
which, how would THAT work?)

So let's try changing the lower-right pixel of each
from black to blue.
Here's the changes for the first picture:

	00029688-E: [same as always]

	0002B32F: 00 01

And after changing it back to black:

	00029688-E: [same as always]
	[no other changes]

Now let's change the lower-right pixel
of picture #2 from black to blue:

	[same stuff]

	0002B33F: 00 01

The corresponding changes on pictures #1 and #2
still seem to be 16 bytes apart!
How is this possible?

Okay, for picture 1,
here's the substantive changes
for changing the upper-left
and lower-right pixels to blue:

	00028720: 00 40 (upper-left)
	0002B32F: 00 01

So how far apart are those?

	0x2b32f - 0x28720
	=
	176,943 - 165,664

11,279 bytes?!!
What a strange encoding.
Maybe each row of pixels
leads directly into the corresponding row
on the next picture?
Like, all the "pictures"
are just tiles excerpted
from a few giant pictures?

But, since the upper-left pixels
of the first two pictures
are 16 bytes apart,
that means that each pixel gets its own byte?
Which, since only four colors are allowed,
would also be crazy inefficient.

I guess I should check
how far the upper-right pixel is
from the upper-left.
That would be:

	0x2ab28 - 0x28720
	174,888 - 165,664
	=
	9,224 bytes!

This seems insane.
Okay, what about the pixel to the RIGHT
of the upper-left pixel?

The difference from baseline there is:

	00028720: 00 10

That's the same byte as the upper-left,
so by moving the pixel to the right,
we get this result:

	40 -> 10
	0100 0000 -> 0001 0000

So, it shifted two bits to the right.
Presumably, then,
this byte encodes the first four pixels
moving right from the upper-left
of the first picture.
I made all four of those pixels blue,
and got this result:

	00028720: 00 55

	55
	0101 0101

So that makes sense, at least.
Making the fifth pixel over blue gives us:

	0002AB20: 05 45

(We're about to run into the pixels
that were already blue, but never mind.)
This makes perfect sense so far.
Switching to the second picture,
which is originally all-black,
and making the first ROW of pixels blue:

	00028730: 00 55

	00028738: 00 55

	0002AB30: 00 55

	0002AB38: 00 55

Crazy, crazy stuff.
Is this inTENded as obfuscation?
The second block of four pixels
is 8 bytes away from the first block.
And the third block is, uh,

	0x2ab30 - 0x28730
	174,898 - 165,680
	=
	9218

9,218 bytes from the first block.

The fourth block is then 8 bytes away from the third.
This is goofy.

So maybe the picture is hacked into quadrants,
and then you run down the first column
with four-pixel blocks,
jump back to the top of the next column,
then move on to the next picture,
and do the upper-left quadrant?
And then, when you're done with all the upper-left quadrants
for all the pictures, you move on to...?
...to the upper-right? or lower-left quadrant?

So maybe within an quadrant it runs like this?

0---8---
1---9---
2---10--
3---11--
4---12--
5---13--
6---14--
7---15--

Okay, let's try setting the pixel below
the upper-right pixel to blue.

	00028731: 00 40

Yep, that makes sense.

Now the one eight--er, seven--down from the upper-left corner:

	00028737: 00 40

Yep, that matches current theory.
Now, the pixel below that:

	00028F30: 00 40

Okay, this MAY be as expected.
It's 0x800 = 2048 from the upper-left pixel set.

____

Okay, I tried implementing things as I understood them,
but the resulting images don't look like anything.
So more research.

I'm gonna change the following pixels
to blue, one at a time,
on picture 2, which is all-black otherwise:

1-------2-------
----------------
----------------
----------------
3-------4-------
----------------
----------------
----------------

...and see where the changes are.

Pixel 1:

C:\Temp\ACS>fc /b 01-Fantasy-Blank.adven.hrd adven.hrd
Comparing files 01-Fantasy-Blank.adven.hrd and ADVEN.HRD
0001C600: 5C 01
0001C601: C0 00
00028730: 00 40

Interestingly, all the junk that changed
when I changed picture 1 similarly
and then just stayed the same
through all the subsequent pixel-twiddling
doesn't seem to have changed
when I edit picture 2?

Anyway, the substantive change
for pixels 1-4, respectively, are:

00028730: 00 40 (1)

00028738: 00 40 (2)

00028F30: 00 40 (3)

00028F38: 00 40 (4)

Now I'll put a breakpoint
in my picture-parsing code
that breaks at the start of every quadrant
for picture 2 (but index 1, I think).

quadrant:
upper-left: 28740
upper-right: 293c0
lower-left: 2a040
lower-right: 2acc0

So, barely off at first, but then way, way off.
First, since pixels 1 and 2
are only 8 bytes away from each other,
That means they're 32 pixel indices away from each other,
which means that I'm wrong about quadrants:
it must skip from the left 4x8 octant of the upper-left quadrant
to the left octant of the upper-right quadrant.
Who knows when it comes back to do the right side
of the upper-left quadrant?
Guess I'd better do some more pixels:

[EDIT: This may not be right?]

1---2---3---4---
h---L-----------
5---6---7---8---
i---------------
9---a---b---c---
j---------------
d---e---f---g---
k---------------


0x2400 - 0x800 = 

Pixel 	Pos		Offset From 1
----- 	---		-------------
1		28730	0x0		=      0
2		2AB30	0x2400  =  9,216
3		28738	0x8		=      8
4		2AB38	0x2408	=  9,224

5		28734	0x4		=      4
6		2AB34	0x2404	=  9,220
7		2873C	0xC		=     12
8		

9		28F30	0x800	=  2,048
a		2B330	0x2c00	= 11,264
b		28F38	0x808	=  2,056
c		2B338	0x2c08  = 11,272

d
e
f
g

h		28731	0x1		=      1
i		28733	0x3		=      3
j
k

L		2AB31

So first 1, then h,
then... what?
I think I might have got some measurements wrong.
Trying again, with a hex editor:

The order, in bytes offset from
0x28730, is:

0...----8...----
1...----9...----
2...----a...----
3...----b...----
4...----c...----
5...----d...----
6...----e...----
7...----f...----
----------------
----------------
----------------
----------------
----------------
----------------
----------------
----------------

The next byte encodes the upper-left pixel
of the subsequent picture!
Assuming that it'll do those two columns of tetrads
in every picture next.
So, that's 16 bytes,
so I guess if you advance (16 x number of pictures) bytes,
then we'll return to some other pixel
in THIS picture.
Maybe it'll be the upper-left pixel
of the left half
of the lower-left quadrant?
That position is, uh, 28F30,
which is 2,048 bytes from the first,
upper-left byte of the picture.
So, dividing 2,048 by 16,
you get, uh, 2^11 / 2^4 = 2^7 = 128
So 128 pictures?
I'll work on those assumptions, then,
and then maybe half the picture will look right.


Text String Encodings
---------------------

A lot of stuff is in ASCII,
like the adventure, author, and region names,
but the names of rooms, things, and possibly creatures,
are not in ASCII.
All these chars are supported:
abcdefghijklmnopqrstuvwxyz
0123456789
!@#$%^&*()
`~-_=+[]{}
,<.>;:'"/?
\|
At least 68 chars are supported.
that's more than 6 bits!

Changing thing 1's name from "Oil and Wick" to "Pil and Wick"
causes these changes:

0001B800: 34 74
			0011 0100
			0111 0100
0001B801: 5F 65
			0101 1111
			0110 0101

Changing it from "Oil and Wick" to "Nil and Wick"
causes these changes:

0001B800: 34 F4
			0011 0100
			1111 0100
0001B801: 5F 58
			0101 1111
			0101 1000

In order, changes go from NIL to PIL:

		0x1b800    0x1b801
AIL		1011 0100  0000 0111
BIL		1111 0100  0000 1101
CIL		0011 0100  0001 0100
DIL		0111 0100  0001 1010
EIL		1011 0100  0010 0000
FIL		1111 0100  0010 0110
GIL		0011 0100  0010 1101

JIL		1111 0100  0011 1111
KIL		0011 0100  0100 0110
LIL		0111 0100  0100 1100
MIL		1011 0100  0101 0010
NIL		1111 0100  0101 1000
OIL		0011 0100  0101 1111
PIL		0111 0100  0110 0101


Let's try reversing the byte order?

		0x1b801    0x1b800    
AIL		0000 0111  1011 0100
BIL		0000 1101  1111 0100
CIL		0001 0100  0011 0100
DIL		0001 1010  0111 0100
EIL		0010 0000  1011 0100
FIL		0010 0110  1111 0100
GIL		0010 1101  0011 0100

JIL		0011 1111  1111 0100
KIL		0100 0110  0011 0100
LIL		0100 1100  0111 0100
MIL		0101 0010  1011 0100
NIL		0101 1000  1111 0100
OIL		0101 1111  0011 0100
PIL		0110 0101  0111 0100

The least significant bits of some letter seem to be the left two.
The right six bits of the first byte have not changed yet,
nor has the one after it.
Those are binary 1101000,
which is hex 68,
which is decimal 96 + 8 = 104
ascii for that is 'h',
which isn't anything in "oil and wick'

Okay... let's try... reversing the BIT order
of the reversed bytes?

		0x1b801    0x1b800    
AIL		1110 0000  0010 1101
BIL		1011 0000  0010 1111
CIL		0010 1000  0010 1100

I don't see anything there either.
What about reversing the bits
of the non-reversed bytes?

		0x1b800    0x1b801
AIL		0010 1101  1110 0000
BIL		0010 1111  1011 0000
CIL		0010 1100  0010 1000
DIL		0010 1110  0101 1000

Nothing.  Reverse those?

AIL		0000 0111  1011 0100
BIL		0000 1101  1111 0100
CIL		0001 0100  0011 0100
DIL		0001 1010  0111 0100

Now cut off the ends?

AIL		0 0111  101
BIL		0 1101  111
CIL		1 0100  001
DIL		1 1010  011

And flip the bits?

AIL		1 1000  010
BIL		1 0010  000
CIL		0 1011  110
DIL		0 0101  100

None of this seems like anything.

Okay, trying again.
Changed thing 2's name
from "dagger" to "" and got:

0001B80A: 2F 00
0001B80B: 19 00
0001B80C: 9A 00
0001B80D: 2C 00

So "dagger" is:

2F 19 9A 2C

which is

2    F     1    9     9    A     2    C
0010 1111  0001 1001  1001 1010  0010 1100

So that's <=8 nibbles for 6 chars.

Let's change it to AAAAAA.

Then it's

0001B80A: 2F 69
0001B80B: 19 06
0001B80C: 9A 69
0001B80D: 2C 06

This looks promising.
That's "6906" twice,
and each 6906 encodes "AAA".
Which is:

6    9     0    6
0110 1001  0000 0110

That's 16 bits,
which doesn't divide equally by 3.
So let's divide unequally,
and throw something away.
Thats 3 groups of 5 bits, with one left over,
probably at the beginning or end?
Assuming we throw away the end, that'd be:

01101 00100 00011

That's not anything.
Reverse the bit orders:

0110 1001  0000 0110
1001 0110  0110 0000

"BBBBBB" becomes d2 0c d2 0c.

d    2    0    c
1101 0010 0000 1100

A single "A" is 40 06.

4    0     0    6
0100 0000  0000	0110
Reversed:

0000 0010  0110 0000

Some kind of Huffman encoding?

Maybe every OTHER byte is reversed?
Back to "AAAAAA",
and reverse every OTHER byte:

6    9     0    6      6    9     0    6   
0110 1001  0000 0110   0110 1001  0000 0110
0110 1001  0110 0000   0110 1001  0110 0000

" A" is just 28 00 00 00.

2    8
0010 1000

"  A" is 01 00 00 00.

0    1     0
0000 0001

And "   A" is 00 00 40 06.
So it definitely seems like 
two bytes are three characters.
But how?

If I do just "AAA", it's 6906,
just as anticipated.
Let's compare AAA to BBB:

AAA
6    9     0    6
0110 1001  0000 0110

BBB
d    2     0    c
1101 0010  0000 1100

In the normal order,
everything's shifted one bit to the left.

CCC
3    b     1    3
0011 1011  0001 0011

DDD
a    4     0    0
1010 0100  0000 0000

EEE
0    d     2    0
0000 1101  0010 0000

FFF
7    6     2    6
0111 0110  0010 0110

GGG
d    f     2    c
1101 1111  0010 1100

HHH
4    8     3    3
0100 1000  0011 0011

The three right bits of the second nibble
count up.

AAB
6    a     0    6
0110 1010  0000 0110

Again,
"  A" is 01 00 00 00.

"  B" is 02 00 00 00

"  C" is 03 00 00 00

"  Z" is 1A 00 00 00
which makes sense,
since 0x1A = 26 decimal.


"AAAAAAA", seven A's,
is 69 06 69 06 40 06
Which is "AAAAAA" plus "A".

Can we brute force this?
What's 26^3?
It's 17,576.  Not great.
Plus, that's just letters.

Okay, like, little-endian?
Reverse the byte order?

AAB
6    a     0    6
0110 1010  0000 0110

LE is 066a?
0000 0110 0110 1010

Forget it, I just adapted this:

https://github.com/danlb2000/ACSViewer/blob/master/TextDecoder.cs